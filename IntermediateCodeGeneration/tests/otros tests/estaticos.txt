.DATA
VT_Object: NOP
VT_System: DW L_MET_System_Ctor, L_MET_System_read, L_MET_System_printI, L_MET_System_printC, L_MET_System_printB, L_MET_System_printS, L_MET_System_println, L_MET_System_printBln, L_MET_System_printCln, L_MET_System_printIln, L_MET_System_printSln 
.CODE
PUSH L_SIMPLE_INIT_HEAP  ; Inicializamos el heap 
CALL
RMEM 1  ; Reservamos memoria para el this 
PUSH L_Main_main  ; Apilamos el label del main de la Clase Principal del Programa 
CALL
HALT
L_MET_System_Ctor: NOP  ; Constructor de system 
LOADFP
LOADSP
STOREFP
STOREFP
RET 1
L_MET_System_read: NOP
LOADFP
LOADSP
STOREFP
READ
STORE 4
STOREFP
RET 1
L_MET_System_printI: NOP
LOADFP
LOADSP
STOREFP
LOAD 4
IPRINT
STOREFP
RET 2
L_MET_System_printC: NOP
LOADFP
LOADSP
STOREFP
LOAD 4
CPRINT
STOREFP
RET 2
L_MET_System_printB: NOP
LOADFP
LOADSP
STOREFP
LOAD 4
BPRINT
STOREFP
RET 2
L_MET_System_printS: NOP
LOADFP
LOADSP
STOREFP
LOAD 4
SPRINT
STOREFP
RET 2
L_MET_System_println: NOP
LOADFP
LOADSP
STOREFP
PRNLN
STOREFP
RET 1
L_MET_System_printBln: NOP
LOADFP
LOADSP
STOREFP
LOAD 4
BPRINT
PRNLN
STOREFP
RET 2
L_MET_System_printCln: NOP
LOADFP
LOADSP
STOREFP
LOAD 4
CPRINT
PRNLN
STOREFP
RET 2
L_MET_System_printIln: NOP
LOADFP
LOADSP
STOREFP
LOAD 4
IPRINT
PRNLN
STOREFP
RET 2
L_MET_System_printSln: NOP
LOADFP
LOADSP
STOREFP
LOAD 4
SPRINT
PRNLN
STOREFP
RET 2
L_SIMPLE_MALLOC: LOADFP  ; Inicializacion unidad 
LOADSP
STOREFP  ; Finaliza inicializacion del RA 
LOADHL  ; hl 
DUP  ; hl 
PUSH 1  ; 1 
ADD  ; hl+1 
STORE 4  ; Guarda resultado (puntero a la base del bloque) 
LOAD 3  ; Carga cantidad de celdas a alojar (parametro)  
ADD
STOREHL  ; Mueve el heap limit (hl) 
STOREFP
RET 1  ; Retorna eliminando el parametro 
L_SIMPLE_INIT_HEAP: RET 0  ; Inicializacion simplificada del .heap 
.DATA
VT_Math: DW L_MET_Math_create, L_MET_Math_get, L_MET_Math_succ, L_MET_Math_mul, L_MET_Math_add, L_MET_Math_pow, L_MET_Math_sub, L_MET_Math_div
.CODE
; Inicializacion CI del servicio 'Math' de clase 'Math'
L_MET_Math_Math: LOADFP  ; Se guarda el enlace dinamico al RA llamador 
LOADSP  ; Se apila el lugar a donde comienza el RA de la unidad 
STOREFP  ; Se actualiza el FP con el valor del tope de la pila 
.CODE
LOAD 8  ; Cargamos el parametro 'a'. 
.CODE
LOAD 3  ; Asignacion. Apilamos THIS 
SWAP  ; Asignacion. Invertimos el orden del tope de la pila. STOREREF usa los parametros en orden inverso (CIR, valor). 
STOREREF 5  ; Asignacion. El lado izquierdo es una variable de instancia de la clase 'Math'. 
.CODE
LOAD 7  ; Cargamos el parametro 'b'. 
.CODE
LOAD 3  ; Asignacion. Apilamos THIS 
SWAP  ; Asignacion. Invertimos el orden del tope de la pila. STOREREF usa los parametros en orden inverso (CIR, valor). 
STOREREF 4  ; Asignacion. El lado izquierdo es una variable de instancia de la clase 'Math'. 
.CODE
LOAD 6  ; Cargamos el parametro 'c'. 
.CODE
LOAD 3  ; Asignacion. Apilamos THIS 
SWAP  ; Asignacion. Invertimos el orden del tope de la pila. STOREREF usa los parametros en orden inverso (CIR, valor). 
STOREREF 3  ; Asignacion. El lado izquierdo es una variable de instancia de la clase 'Math'. 
.CODE
LOAD 5  ; Cargamos el parametro 'd'. 
.CODE
LOAD 3  ; Asignacion. Apilamos THIS 
SWAP  ; Asignacion. Invertimos el orden del tope de la pila. STOREREF usa los parametros en orden inverso (CIR, valor). 
STOREREF 2  ; Asignacion. El lado izquierdo es una variable de instancia de la clase 'Math'. 
.CODE
LOAD 4  ; Cargamos el parametro 'e'. 
.CODE
LOAD 3  ; Asignacion. Apilamos THIS 
SWAP  ; Asignacion. Invertimos el orden del tope de la pila. STOREREF usa los parametros en orden inverso (CIR, valor). 
STOREREF 1  ; Asignacion. El lado izquierdo es una variable de instancia de la clase 'Math'. 
STOREFP ; actualizar el FP para que apunte al RA del llamador
RET 6
.CODE
; Inicializacion CI del servicio 'create' de clase 'Math'
L_MET_Math_create: LOADFP  ; Se guarda el enlace dinamico al RA llamador 
LOADSP  ; Se apila el lugar a donde comienza el RA de la unidad 
STOREFP  ; Se actualiza el FP con el valor del tope de la pila 
.CODE
RMEM 1  ; Llamada al constructor de la clase 'Math'. Se reserva memoria para la referencia al nuevo CIR 
PUSH 6  ; Se apila la cantidad de variables de instancia del nuevo CIR mas el espacio para la VT. 
PUSH L_SIMPLE_MALLOC  ; Se apila la direccion de la rutina para reservar memoria en el heap 
CALL  ; Se invoca a la rutina en el tope de la pila (lsimple_malloc) 
DUP  ; Se duplica la referencia al nuevo CIR para el STOREREF. 
PUSH VT_Math  ; Apilamos la direccion del comienzo de la VT del id en la creacion de un CIR 
STOREREF 0  ; Guardamos las referencia a la VT en el CIR creado. El offset 0 en el CIR se corresponde a la VT 
DUP  ; Se duplica el THIS para el RA del constructor quedando, al finalizar la ejecucion, en el tope de la pila 
.CODE
LOAD 8  ; Cargamos el parametro 'a'. 
.CODE
SWAP  ; Acomodamos el THIS cada vez que generamos el codigo para un parametro. 
.CODE
LOAD 7  ; Cargamos el parametro 'b'. 
.CODE
SWAP  ; Acomodamos el THIS cada vez que generamos el codigo para un parametro. 
.CODE
LOAD 6  ; Cargamos el parametro 'c'. 
.CODE
SWAP  ; Acomodamos el THIS cada vez que generamos el codigo para un parametro. 
.CODE
LOAD 5  ; Cargamos el parametro 'd'. 
.CODE
SWAP  ; Acomodamos el THIS cada vez que generamos el codigo para un parametro. 
.CODE
LOAD 4  ; Cargamos el parametro 'e'. 
.CODE
SWAP  ; Acomodamos el THIS cada vez que generamos el codigo para un parametro. 
.CODE
PUSH L_MET_Math_Math  ; Se apila la direccion del constructor de la clase 'Math'. 
CALL  ; Se invoca a la rutina del constructor de la clase 'Math' 
.CODE
; Retorno de expresion del metodo 'create' de la clase 'Math'
STORE 9  ; Almacenamos el retorno del metodo 'create' de la clase 'Math'. 
STOREFP  ; Actualizamos el FP para que apunte al RA del llamador 
RET 6  ; Retornamos de la unidad liberando el espacio que ocupaban los parametros y el THIS del metodo 'create' de la clase 'Math'. 
STOREFP ; actualizar el FP para que apunte al RA del llamador
RET 6
.CODE
; Inicializacion CI del servicio 'get' de clase 'Math'
L_MET_Math_get: LOADFP  ; Se guarda el enlace dinamico al RA llamador 
LOADSP  ; Se apila el lugar a donde comienza el RA de la unidad 
STOREFP  ; Se actualiza el FP con el valor del tope de la pila 
.CODE
LOAD 3  ; Apilamos el THIS para invocar al metodo 'div' 
RMEM 1  ; Reservamos una locacion de memoria para el resultado del metodo 'div' de la clase 'Math' 
SWAP  ; Acomodamos el THIS haciendo un SWAP con RETVAL 
.CODE
PUSH VT_Math
SWAP  ; Acomodamos el THIS cada vez que generamos el codigo para un parametro. 
.CODE
LOAD 3  ; Apilamos el THIS para poder acceder al CIR. 
LOADREF 1  ; Cargamos la variable de instancia '_e'. 
SWAP  ; Acomodamos el THIS cada vez que generamos el codigo para un parametro. 
DUP  ; Duplicamos la referencia al CIR para utilizarla en el LOADREF al asociar la VT para invocar al metodo 'div'. 
LOADREF 0  ; El offset de la VT en el CIR es siempre 0. Accedemos a la VT. 
LOADREF 7  ; Recuperamos la direccion del metodo 'div'. 
CALL  ; Llamamos al metodo 'div'. 
.CODE
; Retorno de expresion del metodo 'get' de la clase 'Math'
STORE 4  ; Almacenamos el retorno del metodo 'get' de la clase 'Math'. 
STOREFP  ; Actualizamos el FP para que apunte al RA del llamador 
RET 1  ; Retornamos de la unidad liberando el espacio que ocupaban los parametros y el THIS del metodo 'get' de la clase 'Math'. 
STOREFP ; actualizar el FP para que apunte al RA del llamador
RET 1
.CODE
; Inicializacion CI del servicio 'succ' de clase 'Math'
L_MET_Math_succ: LOADFP  ; Se guarda el enlace dinamico al RA llamador 
LOADSP  ; Se apila el lugar a donde comienza el RA de la unidad 
STOREFP  ; Se actualiza el FP con el valor del tope de la pila 
.CODE
LOAD 4  ; Cargamos el parametro 'a'. 
.CODE
PUSH 1
.CODE
ADD
.CODE
; Retorno de expresion del metodo 'succ' de la clase 'Math'
STORE 5  ; Almacenamos el retorno del metodo 'succ' de la clase 'Math'. 
STOREFP  ; Actualizamos el FP para que apunte al RA del llamador 
RET 2  ; Retornamos de la unidad liberando el espacio que ocupaban los parametros y el THIS del metodo 'succ' de la clase 'Math'. 
STOREFP ; actualizar el FP para que apunte al RA del llamador
RET 2
.CODE
; Inicializacion CI del servicio 'mul' de clase 'Math'
L_MET_Math_mul: LOADFP  ; Se guarda el enlace dinamico al RA llamador 
LOADSP  ; Se apila el lugar a donde comienza el RA de la unidad 
STOREFP  ; Se actualiza el FP con el valor del tope de la pila 
.CODE
LOAD 4  ; Cargamos el parametro 'b'. 
.CODE
PUSH 0
.CODE
EQ
.CODE
BF L_ENDIF_1_mul_Math
.CODE
PUSH 0
.CODE
; Retorno de expresion del metodo 'mul' de la clase 'Math'
STORE 6  ; Almacenamos el retorno del metodo 'mul' de la clase 'Math'. 
STOREFP  ; Actualizamos el FP para que apunte al RA del llamador 
RET 3  ; Retornamos de la unidad liberando el espacio que ocupaban los parametros y el THIS del metodo 'mul' de la clase 'Math'. 
JUMP L_ENDELSE_1_mul_Math
L_ENDIF_1_mul_Math: NOP
.CODE
LOAD 3  ; Apilamos el THIS para invocar al metodo 'add' 
RMEM 1  ; Reservamos una locacion de memoria para el resultado del metodo 'add' de la clase 'Math' 
SWAP  ; Acomodamos el THIS haciendo un SWAP con RETVAL 
.CODE
LOAD 5  ; Cargamos el parametro 'a'. 
SWAP  ; Acomodamos el THIS cada vez que generamos el codigo para un parametro. 
.CODE
LOAD 3  ; Apilamos el THIS para invocar al metodo 'mul' 
RMEM 1  ; Reservamos una locacion de memoria para el resultado del metodo 'mul' de la clase 'Math' 
SWAP  ; Acomodamos el THIS haciendo un SWAP con RETVAL 
.CODE
LOAD 5  ; Cargamos el parametro 'a'. 
SWAP  ; Acomodamos el THIS cada vez que generamos el codigo para un parametro. 
.CODE
LOAD 4  ; Cargamos el parametro 'b'. 
.CODE
PUSH 1
.CODE
SUB
SWAP  ; Acomodamos el THIS cada vez que generamos el codigo para un parametro. 
DUP  ; Duplicamos la referencia al CIR para utilizarla en el LOADREF al asociar la VT para invocar al metodo 'mul'. 
LOADREF 0  ; El offset de la VT en el CIR es siempre 0. Accedemos a la VT. 
LOADREF 3  ; Recuperamos la direccion del metodo 'mul'. 
CALL  ; Llamamos al metodo 'mul'. 
SWAP  ; Acomodamos el THIS cada vez que generamos el codigo para un parametro. 
DUP  ; Duplicamos la referencia al CIR para utilizarla en el LOADREF al asociar la VT para invocar al metodo 'add'. 
LOADREF 0  ; El offset de la VT en el CIR es siempre 0. Accedemos a la VT. 
LOADREF 4  ; Recuperamos la direccion del metodo 'add'. 
CALL  ; Llamamos al metodo 'add'. 
.CODE
; Retorno de expresion del metodo 'mul' de la clase 'Math'
STORE 6  ; Almacenamos el retorno del metodo 'mul' de la clase 'Math'. 
STOREFP  ; Actualizamos el FP para que apunte al RA del llamador 
RET 3  ; Retornamos de la unidad liberando el espacio que ocupaban los parametros y el THIS del metodo 'mul' de la clase 'Math'. 
L_ENDELSE_1_mul_Math: NOP
STOREFP ; actualizar el FP para que apunte al RA del llamador
RET 3
.CODE
; Inicializacion CI del servicio 'add' de clase 'Math'
L_MET_Math_add: LOADFP  ; Se guarda el enlace dinamico al RA llamador 
LOADSP  ; Se apila el lugar a donde comienza el RA de la unidad 
STOREFP  ; Se actualiza el FP con el valor del tope de la pila 
.CODE
LOAD 4  ; Cargamos el parametro 'b'. 
.CODE
PUSH 0
.CODE
EQ
.CODE
BF L_ENDIF_2_add_Math
.CODE
LOAD 5  ; Cargamos el parametro 'a'. 
.CODE
; Retorno de expresion del metodo 'add' de la clase 'Math'
STORE 6  ; Almacenamos el retorno del metodo 'add' de la clase 'Math'. 
STOREFP  ; Actualizamos el FP para que apunte al RA del llamador 
RET 3  ; Retornamos de la unidad liberando el espacio que ocupaban los parametros y el THIS del metodo 'add' de la clase 'Math'. 
JUMP L_ENDELSE_2_add_Math
L_ENDIF_2_add_Math: NOP
.CODE
LOAD 3  ; Apilamos el THIS para invocar al metodo 'succ' 
RMEM 1  ; Reservamos una locacion de memoria para el resultado del metodo 'succ' de la clase 'Math' 
SWAP  ; Acomodamos el THIS haciendo un SWAP con RETVAL 
.CODE
LOAD 3  ; Apilamos el THIS para invocar al metodo 'add' 
RMEM 1  ; Reservamos una locacion de memoria para el resultado del metodo 'add' de la clase 'Math' 
SWAP  ; Acomodamos el THIS haciendo un SWAP con RETVAL 
.CODE
LOAD 5  ; Cargamos el parametro 'a'. 
SWAP  ; Acomodamos el THIS cada vez que generamos el codigo para un parametro. 
.CODE
LOAD 4  ; Cargamos el parametro 'b'. 
.CODE
PUSH 1
.CODE
SUB
SWAP  ; Acomodamos el THIS cada vez que generamos el codigo para un parametro. 
DUP  ; Duplicamos la referencia al CIR para utilizarla en el LOADREF al asociar la VT para invocar al metodo 'add'. 
LOADREF 0  ; El offset de la VT en el CIR es siempre 0. Accedemos a la VT. 
LOADREF 4  ; Recuperamos la direccion del metodo 'add'. 
CALL  ; Llamamos al metodo 'add'. 
SWAP  ; Acomodamos el THIS cada vez que generamos el codigo para un parametro. 
DUP  ; Duplicamos la referencia al CIR para utilizarla en el LOADREF al asociar la VT para invocar al metodo 'succ'. 
LOADREF 0  ; El offset de la VT en el CIR es siempre 0. Accedemos a la VT. 
LOADREF 2  ; Recuperamos la direccion del metodo 'succ'. 
CALL  ; Llamamos al metodo 'succ'. 
.CODE
; Retorno de expresion del metodo 'add' de la clase 'Math'
STORE 6  ; Almacenamos el retorno del metodo 'add' de la clase 'Math'. 
STOREFP  ; Actualizamos el FP para que apunte al RA del llamador 
RET 3  ; Retornamos de la unidad liberando el espacio que ocupaban los parametros y el THIS del metodo 'add' de la clase 'Math'. 
L_ENDELSE_2_add_Math: NOP
STOREFP ; actualizar el FP para que apunte al RA del llamador
RET 3
.CODE
; Inicializacion CI del servicio 'pow' de clase 'Math'
L_MET_Math_pow: LOADFP  ; Se guarda el enlace dinamico al RA llamador 
LOADSP  ; Se apila el lugar a donde comienza el RA de la unidad 
STOREFP  ; Se actualiza el FP con el valor del tope de la pila 
.CODE
LOAD 4  ; Cargamos el parametro 'b'. 
.CODE
PUSH 0
.CODE
EQ
.CODE
BF L_ENDIF_3_pow_Math
.CODE
PUSH 1
.CODE
; Retorno de expresion del metodo 'pow' de la clase 'Math'
STORE 6  ; Almacenamos el retorno del metodo 'pow' de la clase 'Math'. 
STOREFP  ; Actualizamos el FP para que apunte al RA del llamador 
RET 3  ; Retornamos de la unidad liberando el espacio que ocupaban los parametros y el THIS del metodo 'pow' de la clase 'Math'. 
JUMP L_ENDELSE_3_pow_Math
L_ENDIF_3_pow_Math: NOP
.CODE
LOAD 5  ; Cargamos el parametro 'a'. 
.CODE
LOAD 3  ; Apilamos el THIS para invocar al metodo 'pow' 
RMEM 1  ; Reservamos una locacion de memoria para el resultado del metodo 'pow' de la clase 'Math' 
SWAP  ; Acomodamos el THIS haciendo un SWAP con RETVAL 
.CODE
LOAD 5  ; Cargamos el parametro 'a'. 
SWAP  ; Acomodamos el THIS cada vez que generamos el codigo para un parametro. 
.CODE
LOAD 4  ; Cargamos el parametro 'b'. 
.CODE
PUSH 1
.CODE
SUB
SWAP  ; Acomodamos el THIS cada vez que generamos el codigo para un parametro. 
DUP  ; Duplicamos la referencia al CIR para utilizarla en el LOADREF al asociar la VT para invocar al metodo 'pow'. 
LOADREF 0  ; El offset de la VT en el CIR es siempre 0. Accedemos a la VT. 
LOADREF 5  ; Recuperamos la direccion del metodo 'pow'. 
CALL  ; Llamamos al metodo 'pow'. 
.CODE
MUL
.CODE
; Retorno de expresion del metodo 'pow' de la clase 'Math'
STORE 6  ; Almacenamos el retorno del metodo 'pow' de la clase 'Math'. 
STOREFP  ; Actualizamos el FP para que apunte al RA del llamador 
RET 3  ; Retornamos de la unidad liberando el espacio que ocupaban los parametros y el THIS del metodo 'pow' de la clase 'Math'. 
L_ENDELSE_3_pow_Math: NOP
STOREFP ; actualizar el FP para que apunte al RA del llamador
RET 3
.CODE
; Inicializacion CI del servicio 'sub' de clase 'Math'
L_MET_Math_sub: LOADFP  ; Se guarda el enlace dinamico al RA llamador 
LOADSP  ; Se apila el lugar a donde comienza el RA de la unidad 
STOREFP  ; Se actualiza el FP con el valor del tope de la pila 
.CODE
LOAD 5  ; Cargamos el parametro 'a'. 
.CODE
LOAD 4  ; Cargamos el parametro 'b'. 
.CODE
SUB
.CODE
; Retorno de expresion del metodo 'sub' de la clase 'Math'
STORE 6  ; Almacenamos el retorno del metodo 'sub' de la clase 'Math'. 
STOREFP  ; Actualizamos el FP para que apunte al RA del llamador 
RET 3  ; Retornamos de la unidad liberando el espacio que ocupaban los parametros y el THIS del metodo 'sub' de la clase 'Math'. 
STOREFP ; actualizar el FP para que apunte al RA del llamador
RET 3
.CODE
; Inicializacion CI del servicio 'div' de clase 'Math'
L_MET_Math_div: LOADFP  ; Se guarda el enlace dinamico al RA llamador 
LOADSP  ; Se apila el lugar a donde comienza el RA de la unidad 
STOREFP  ; Se actualiza el FP con el valor del tope de la pila 
.CODE
LOAD 5  ; Cargamos el parametro 'a'. 
.CODE
LOAD 4  ; Cargamos el parametro 'b'. 
.CODE
DIV
.CODE
; Retorno de expresion del metodo 'div' de la clase 'Math'
STORE 6  ; Almacenamos el retorno del metodo 'div' de la clase 'Math'. 
STOREFP  ; Actualizamos el FP para que apunte al RA del llamador 
RET 3  ; Retornamos de la unidad liberando el espacio que ocupaban los parametros y el THIS del metodo 'div' de la clase 'Math'. 
STOREFP ; actualizar el FP para que apunte al RA del llamador
RET 3
.DATA
VT_Main: DW L_MET_Main_main, L_MET_Math_create, L_MET_Math_get, L_MET_Math_succ, L_MET_Math_mul, L_MET_Math_add, L_MET_Math_pow, L_MET_Math_sub, L_MET_Math_div
.CODE
; Inicializacion CI del servicio 'Main' de clase 'Main'
L_MET_Main_Main: LOADFP  ; Se guarda el enlace dinamico al RA llamador 
LOADSP  ; Se apila el lugar a donde comienza el RA de la unidad 
STOREFP  ; Se actualiza el FP con el valor del tope de la pila 
STOREFP ; actualizar el FP para que apunte al RA del llamador
RET 1
.CODE
; Inicializacion CI del servicio 'main' de clase 'Main'
L_MET_Main_main: LOADFP  ; Se guarda el enlace dinamico al RA llamador 
LOADSP  ; Se apila el lugar a donde comienza el RA de la unidad 
STOREFP  ; Se actualiza el FP con el valor del tope de la pila 
.CODE
PUSH VT_System
.CODE
PUSH VT_System
STOREFP ; actualizar el FP para que apunte al RA del llamador
RET 1
