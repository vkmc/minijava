.DATA
VT_Object: NOP
VT_SYSTEM: DW L_SYSTEM_CTOR, L_SYSTEM_PRINTI, L_SYSTEM_READ, L_SYSTEM_PRINTC, L_SYSTEM_PRINTB, L_SYSTEM_PRINTS, L_SYSTEM_PRINTLN, L_SYSTEM_PRINTBLN, L_SYSTEM_PRINTCLN, L_SYSTEM_PRINTILN, L_SYSTEM_PRINTSLN 
.CODE
PUSH L_SIMPLE_INIT_HEAP  ; Inicializamos el heap 
CALL
RMEM 1  ; Reservamos memoria para el this 
PUSH L_MainClass_main  ; Apilamos el label del main de la Clase Principal del Programa 
CALL
HALT
L_SYSTEM_CTOR: NOP  ; Constructor de system 
LOADFP
LOADSP
STOREFP
STOREFP
RET 1
L_SYSTEM_READ: NOP
LOADFP
LOADSP
STOREFP
READ
STORE 4
STOREFP
RET 1
L_SYSTEM_PRINTI: NOP
LOADFP
LOADSP
STOREFP
LOAD 4
IPRINT
STOREFP
RET 2
L_SYSTEM_PRINTC: NOP
LOADFP
LOADSP
STOREFP
LOAD 4
CPRINT
STOREFP
RET 2
L_SYSTEM_PRINTB: NOP
LOADFP
LOADSP
STOREFP
LOAD 4
BPRINT
STOREFP
RET 2
L_SYSTEM_PRINTS: NOP
LOADFP
LOADSP
STOREFP
LOAD 4
SPRINT
STOREFP
RET 2
L_SYSTEM_PRINTLN: NOP
LOADFP
LOADSP
STOREFP
PRNLN
STOREFP
RET 1
L_SYSTEM_PRINTBLN: NOP
LOADFP
LOADSP
STOREFP
LOAD 4
BPRINT
PRNLN
STOREFP
RET 2
L_SYSTEM_PRINTCLN: NOP
LOADFP
LOADSP
STOREFP
LOAD 4
CPRINT
PRNLN
STOREFP
RET 2
L_SYSTEM_PRINTILN: NOP
LOADFP
LOADSP
STOREFP
LOAD 4
IPRINT
PRNLN
STOREFP
RET 2
L_SYSTEM_PRINTSLN: NOP
LOADFP
LOADSP
STOREFP
LOAD 4
SPRINT
PRNLN
STOREFP
RET 2
L_SIMPLE_MALLOC: LOADFP  ; Inicializacion unidad 
LOADSP
STOREFP  ; Finaliza inicializacion del RA 
LOADHL  ; hl 
DUP  ; hl 
PUSH 1  ; 1 
ADD  ; hl+1 
STORE 4  ; Guarda resultado (puntero a la base del bloque) 
LOAD 3  ; Carga cantidad de celdas a alojar (parametro)  
ADD
STOREHL  ; Mueve el heap limit (hl) 
STOREFP
RET 1  ; Retorna eliminando el parametro 
L_SIMPLE_INIT_HEAP: RET 0  ; Inicializacion simplificada del .heap 
.DATA
VT_IntLinkedList: DW L_IntLinkedList_getSize ,L_IntLinkedList_addFirst ,L_IntLinkedList_addLast ,L_IntLinkedList_add ,L_IntLinkedList_getFirst ,L_IntLinkedList_getLast ,L_IntLinkedList_get 
.CODE
L_IntLinkedList_IntLinkedList: LOADFP  ; Se guarda el enlace dinamico al RA llamador 
LOADSP  ; Se apila el lugar a donde comienza el RA de la unidad 
STOREFP  ; Se actualiza el FP con el valor del tope de la pila 
.CODE
PUSH 0
.CODE
LOAD 3  ; Asignacion. Apilamos THIS 
SWAP  ; Asignacion. Invertimos el orden del tope de la pila. STOREREF usa los parametros en orden inverso (CIR, valor). 
STOREREF 1  ; Asignacion. El lado izquierdo es una variable de instancia de la clase 'IntLinkedList'. 
.CODE
RMEM 1  ; Llamada al constructor de la clase 'IntElement'. Se reserva memoria para la referencia al nuevo CIR 
PUSH 3  ; Se apila la cantidad de variables de instancia del nuevo CIR mas el espacio para la VT. 
PUSH L_SIMPLE_MALLOC  ; Se apila la direccion de la rutina para reservar memoria en el heap 
CALL  ; Se invoca a la rutina en el tope de la pila (lsimple_malloc) 
DUP  ; Se duplica la referencia al nuevo CIR para el STOREREF. 
PUSH VT_IntElement  ; Apilamos la direccion del comienzo de la VT del id en la creacion de un CIR 
STOREREF 0  ; Guardamos las referencia a la VT en el CIR creado. El offset 0 en el CIR se corresponde a la VT 
DUP  ; Se duplica el THIS para el RA del constructor quedando, al finalizar la ejecucion, en el tope de la pila 
.CODE
PUSH 0
.CODE
SWAP  ; Acomodamos el THIS cada vez que generamos el codigo para un parametro. 
.CODE
PUSH L_IntElement_IntElement  ; Se apila la direccion del constructor de la clase 'IntElement'. 
CALL  ; Se invoca a la rutina del constructor de la clase 'IntElement' 
.CODE
LOAD 3  ; Asignacion. Apilamos THIS 
SWAP  ; Asignacion. Invertimos el orden del tope de la pila. STOREREF usa los parametros en orden inverso (CIR, valor). 
STOREREF 3  ; Asignacion. El lado izquierdo es una variable de instancia de la clase 'IntLinkedList'. 
.CODE
LOAD 3  ; Apilamos el THIS para poder acceder al CIR. 
LOADREF 3  ; Cargamos la variable de instancia 'first'. 
.CODE
.CODE
PUSH 0  ; Apilamos 'null' 
SWAP  ; Acomodamos el THIS cada vez que generamos el codigo para un parametro. 
.CODE
DUP  ; Duplicamos la referencia al CIR para utilizarla en el LOADREF al asociar la VT para invocar al metodo 'setNext'. 
LOADREF 0  ; El offset de la VT en el CIR es siempre 0. Accedemos a la VT. 
LOADREF 0  ; Recuperamos la direccion del metodo 'setNext'. 
CALL  ; Llamamos al metodo 'setNext'. 
.CODE
PUSH 0  ; Apilamos 'null' 
.CODE
LOAD 3  ; Asignacion. Apilamos THIS 
SWAP  ; Asignacion. Invertimos el orden del tope de la pila. STOREREF usa los parametros en orden inverso (CIR, valor). 
STOREREF 2  ; Asignacion. El lado izquierdo es una variable de instancia de la clase 'IntLinkedList'. 
STOREFP ; actualizar el FP para que apunte al RA del llamador
RET 1
.CODE
L_IntLinkedList_getSize: LOADFP  ; Se guarda el enlace dinamico al RA llamador 
LOADSP  ; Se apila el lugar a donde comienza el RA de la unidad 
STOREFP  ; Se actualiza el FP con el valor del tope de la pila 
.CODE
LOAD 3  ; Apilamos el THIS para poder acceder al CIR. 
LOADREF 1  ; Cargamos la variable de instancia 'size'. 
.CODE
; Retorno de expresion del metodo 'getSize' de la clase 'IntLinkedList'
STORE 4  ; Almacenamos el retorno del metodo 'getSize' de la clase 'IntLinkedList'. 
STOREFP  ; Actualizamos el FP para que apunte al RA del llamador 
RET 1  ; Retornamos de la unidad liberando el espacio que ocupaban los parametros y el THIS del metodo 'getSize' de la clase 'IntLinkedList'. 
STOREFP ; actualizar el FP para que apunte al RA del llamador
RET 1
.CODE
L_IntLinkedList_addFirst: LOADFP  ; Se guarda el enlace dinamico al RA llamador 
LOADSP  ; Se apila el lugar a donde comienza el RA de la unidad 
STOREFP  ; Se actualiza el FP con el valor del tope de la pila 
RMEM 1  ; Reservamos espacio para las variables locales del metodo 'addFirst' 
.CODE
RMEM 1  ; Llamada al constructor de la clase 'IntElement'. Se reserva memoria para la referencia al nuevo CIR 
PUSH 3  ; Se apila la cantidad de variables de instancia del nuevo CIR mas el espacio para la VT. 
PUSH L_SIMPLE_MALLOC  ; Se apila la direccion de la rutina para reservar memoria en el heap 
CALL  ; Se invoca a la rutina en el tope de la pila (lsimple_malloc) 
DUP  ; Se duplica la referencia al nuevo CIR para el STOREREF. 
PUSH VT_IntElement  ; Apilamos la direccion del comienzo de la VT del id en la creacion de un CIR 
STOREREF 0  ; Guardamos las referencia a la VT en el CIR creado. El offset 0 en el CIR se corresponde a la VT 
DUP  ; Se duplica el THIS para el RA del constructor quedando, al finalizar la ejecucion, en el tope de la pila 
.CODE
LOAD 4  ; Cargamos el parametro 'e'. 
.CODE
SWAP  ; Acomodamos el THIS cada vez que generamos el codigo para un parametro. 
.CODE
PUSH L_IntElement_IntElement  ; Se apila la direccion del constructor de la clase 'IntElement'. 
CALL  ; Se invoca a la rutina del constructor de la clase 'IntElement' 
.CODE
STORE 0  ; Asignacion. El lado izquierdo es una variable local del metodo 'addFirst' 
.CODE
LOAD 0  ; Cargamos la variable local 'element'. 
.CODE
.CODE
LOAD 3  ; Apilamos el THIS para poder acceder al CIR. 
LOADREF 3  ; Cargamos la variable de instancia 'first'. 
.CODE
RMEM 1  ; Reservamos una locacion de memoria para el resultado del metodo 'addFirst' de la clase 'IntLinkedList' 
SWAP  ; Acomodamos el THIS haciendo un SWAP con RETVAL 
.CODE
DUP  ; Duplicamos la referencia al CIR para utilizarla en el LOADREF al asociar la VT para invocar al metodo 'getNext'. 
LOADREF 0  ; El offset de la VT en el CIR es siempre 0. Accedemos a la VT. 
LOADREF 2  ; Recuperamos la direccion del metodo 'getNext'. 
CALL  ; Llamamos al metodo 'getNext'. 
SWAP  ; Acomodamos el THIS cada vez que generamos el codigo para un parametro. 
.CODE
DUP  ; Duplicamos la referencia al CIR para utilizarla en el LOADREF al asociar la VT para invocar al metodo 'setNext'. 
LOADREF 0  ; El offset de la VT en el CIR es siempre 0. Accedemos a la VT. 
LOADREF 0  ; Recuperamos la direccion del metodo 'setNext'. 
CALL  ; Llamamos al metodo 'setNext'. 
.CODE
LOAD 3  ; Apilamos el THIS para poder acceder al CIR. 
LOADREF 3  ; Cargamos la variable de instancia 'first'. 
.CODE
.CODE
LOAD 0  ; Cargamos la variable local 'element'. 
SWAP  ; Acomodamos el THIS cada vez que generamos el codigo para un parametro. 
.CODE
DUP  ; Duplicamos la referencia al CIR para utilizarla en el LOADREF al asociar la VT para invocar al metodo 'setNext'. 
LOADREF 0  ; El offset de la VT en el CIR es siempre 0. Accedemos a la VT. 
LOADREF 0  ; Recuperamos la direccion del metodo 'setNext'. 
CALL  ; Llamamos al metodo 'setNext'. 
.CODE
LOAD 3  ; Apilamos el THIS para poder acceder al CIR. 
LOADREF 1  ; Cargamos la variable de instancia 'size'. 
.CODE
PUSH 1
.CODE
ADD
.CODE
LOAD 3  ; Asignacion. Apilamos THIS 
SWAP  ; Asignacion. Invertimos el orden del tope de la pila. STOREREF usa los parametros en orden inverso (CIR, valor). 
STOREREF 1  ; Asignacion. El lado izquierdo es una variable de instancia de la clase 'IntLinkedList'. 
.CODE
LOAD 3  ; Apilamos el THIS para poder acceder al CIR. 
LOADREF 1  ; Cargamos la variable de instancia 'size'. 
.CODE
PUSH 1
.CODE
EQ
.CODE
BF L_ENDIFTHEN_1_addFirst_IntLinkedList
.CODE
LOAD 3  ; Apilamos el THIS para poder acceder al CIR. 
LOADREF 3  ; Cargamos la variable de instancia 'first'. 
.CODE
RMEM 1  ; Reservamos una locacion de memoria para el resultado del metodo 'addFirst' de la clase 'IntLinkedList' 
SWAP  ; Acomodamos el THIS haciendo un SWAP con RETVAL 
.CODE
DUP  ; Duplicamos la referencia al CIR para utilizarla en el LOADREF al asociar la VT para invocar al metodo 'getNext'. 
LOADREF 0  ; El offset de la VT en el CIR es siempre 0. Accedemos a la VT. 
LOADREF 2  ; Recuperamos la direccion del metodo 'getNext'. 
CALL  ; Llamamos al metodo 'getNext'. 
.CODE
LOAD 3  ; Asignacion. Apilamos THIS 
SWAP  ; Asignacion. Invertimos el orden del tope de la pila. STOREREF usa los parametros en orden inverso (CIR, valor). 
STOREREF 2  ; Asignacion. El lado izquierdo es una variable de instancia de la clase 'IntLinkedList'. 
L_ENDIFTHEN_1_addFirst_IntLinkedList: NOP
.CODE
PUSH 1  ; Apilamos 'true' 
.CODE
; Retorno de expresion del metodo 'addFirst' de la clase 'IntLinkedList'
STORE 5  ; Almacenamos el retorno del metodo 'addFirst' de la clase 'IntLinkedList'. 
FMEM 1  ; Liberamos el espacio usado por las variables locales del metodo 'addFirst' de la clase 'IntLinkedList'. 
STOREFP  ; Actualizamos el FP para que apunte al RA del llamador 
RET 2  ; Retornamos de la unidad liberando el espacio que ocupaban los parametros y el THIS del metodo 'addFirst' de la clase 'IntLinkedList'. 
FMEM 1  ; Liberamos espacio para las variables locales del metodo 'addFirst' 
STOREFP ; actualizar el FP para que apunte al RA del llamador
RET 2
.CODE
L_IntLinkedList_addLast: LOADFP  ; Se guarda el enlace dinamico al RA llamador 
LOADSP  ; Se apila el lugar a donde comienza el RA de la unidad 
STOREFP  ; Se actualiza el FP con el valor del tope de la pila 
RMEM 1  ; Reservamos espacio para las variables locales del metodo 'addLast' 
.CODE
RMEM 1  ; Llamada al constructor de la clase 'IntElement'. Se reserva memoria para la referencia al nuevo CIR 
PUSH 3  ; Se apila la cantidad de variables de instancia del nuevo CIR mas el espacio para la VT. 
PUSH L_SIMPLE_MALLOC  ; Se apila la direccion de la rutina para reservar memoria en el heap 
CALL  ; Se invoca a la rutina en el tope de la pila (lsimple_malloc) 
DUP  ; Se duplica la referencia al nuevo CIR para el STOREREF. 
PUSH VT_IntElement  ; Apilamos la direccion del comienzo de la VT del id en la creacion de un CIR 
STOREREF 0  ; Guardamos las referencia a la VT en el CIR creado. El offset 0 en el CIR se corresponde a la VT 
DUP  ; Se duplica el THIS para el RA del constructor quedando, al finalizar la ejecucion, en el tope de la pila 
.CODE
LOAD 4  ; Cargamos el parametro 'e'. 
.CODE
SWAP  ; Acomodamos el THIS cada vez que generamos el codigo para un parametro. 
.CODE
PUSH L_IntElement_IntElement  ; Se apila la direccion del constructor de la clase 'IntElement'. 
CALL  ; Se invoca a la rutina del constructor de la clase 'IntElement' 
.CODE
STORE 0  ; Asignacion. El lado izquierdo es una variable local del metodo 'addLast' 
.CODE
LOAD 3  ; Apilamos el THIS para poder acceder al CIR. 
LOADREF 2  ; Cargamos la variable de instancia 'last'. 
.CODE
.CODE
LOAD 0  ; Cargamos la variable local 'element'. 
SWAP  ; Acomodamos el THIS cada vez que generamos el codigo para un parametro. 
.CODE
DUP  ; Duplicamos la referencia al CIR para utilizarla en el LOADREF al asociar la VT para invocar al metodo 'setNext'. 
LOADREF 0  ; El offset de la VT en el CIR es siempre 0. Accedemos a la VT. 
LOADREF 0  ; Recuperamos la direccion del metodo 'setNext'. 
CALL  ; Llamamos al metodo 'setNext'. 
.CODE
LOAD 3  ; Apilamos el THIS para poder acceder al CIR. 
LOADREF 1  ; Cargamos la variable de instancia 'size'. 
.CODE
PUSH 1
.CODE
ADD
.CODE
LOAD 3  ; Asignacion. Apilamos THIS 
SWAP  ; Asignacion. Invertimos el orden del tope de la pila. STOREREF usa los parametros en orden inverso (CIR, valor). 
STOREREF 1  ; Asignacion. El lado izquierdo es una variable de instancia de la clase 'IntLinkedList'. 
.CODE
LOAD 0  ; Cargamos la variable local 'element'. 
.CODE
LOAD 3  ; Asignacion. Apilamos THIS 
SWAP  ; Asignacion. Invertimos el orden del tope de la pila. STOREREF usa los parametros en orden inverso (CIR, valor). 
STOREREF 2  ; Asignacion. El lado izquierdo es una variable de instancia de la clase 'IntLinkedList'. 
.CODE
PUSH 1  ; Apilamos 'true' 
.CODE
; Retorno de expresion del metodo 'addLast' de la clase 'IntLinkedList'
STORE 5  ; Almacenamos el retorno del metodo 'addLast' de la clase 'IntLinkedList'. 
FMEM 1  ; Liberamos el espacio usado por las variables locales del metodo 'addLast' de la clase 'IntLinkedList'. 
STOREFP  ; Actualizamos el FP para que apunte al RA del llamador 
RET 2  ; Retornamos de la unidad liberando el espacio que ocupaban los parametros y el THIS del metodo 'addLast' de la clase 'IntLinkedList'. 
FMEM 1  ; Liberamos espacio para las variables locales del metodo 'addLast' 
STOREFP ; actualizar el FP para que apunte al RA del llamador
RET 2
.CODE
L_IntLinkedList_add: LOADFP  ; Se guarda el enlace dinamico al RA llamador 
LOADSP  ; Se apila el lugar a donde comienza el RA de la unidad 
STOREFP  ; Se actualiza el FP con el valor del tope de la pila 
RMEM 3  ; Reservamos espacio para las variables locales del metodo 'add' 
.CODE
LOAD 5  ; Cargamos el parametro 'index'. 
.CODE
LOAD 3  ; Apilamos el THIS para poder acceder al CIR. 
LOADREF 1  ; Cargamos la variable de instancia 'size'. 
.CODE
GE
.CODE
LOAD 5  ; Cargamos el parametro 'index'. 
.CODE
PUSH 0
.CODE
LT
.CODE
OR
.CODE
BF L_ENDIFTHEN_2_add_IntLinkedList
.CODE
PUSH 0  ; Apilamos 'false' 
.CODE
; Retorno de expresion del metodo 'add' de la clase 'IntLinkedList'
STORE 6  ; Almacenamos el retorno del metodo 'add' de la clase 'IntLinkedList'. 
FMEM 3  ; Liberamos el espacio usado por las variables locales del metodo 'add' de la clase 'IntLinkedList'. 
STOREFP  ; Actualizamos el FP para que apunte al RA del llamador 
RET 3  ; Retornamos de la unidad liberando el espacio que ocupaban los parametros y el THIS del metodo 'add' de la clase 'IntLinkedList'. 
L_ENDIFTHEN_2_add_IntLinkedList: NOP
.CODE
LOAD 5  ; Cargamos el parametro 'index'. 
.CODE
LOAD 3  ; Apilamos el THIS para poder acceder al CIR. 
LOADREF 1  ; Cargamos la variable de instancia 'size'. 
.CODE
PUSH 1
.CODE
SUB
.CODE
EQ
.CODE
BF L_ENDIFTHEN_3_add_IntLinkedList
.CODE
LOAD 3  ; Apilamos el THIS para invocar al metodo 'addLast' 
RMEM 1  ; Reservamos una locacion de memoria para el resultado del metodo 'addLast' de la clase 'IntLinkedList' 
SWAP  ; Acomodamos el THIS haciendo un SWAP con RETVAL 
.CODE
LOAD 4  ; Cargamos el parametro 'e'. 
SWAP  ; Acomodamos el THIS cada vez que generamos el codigo para un parametro. 
DUP  ; Duplicamos la referencia al CIR para utilizarla en el LOADREF al asociar la VT para invocar al metodo 'addLast'. 
LOADREF 0  ; El offset de la VT en el CIR es siempre 0. Accedemos a la VT. 
LOADREF 2  ; Recuperamos la direccion del metodo 'addLast'. 
CALL  ; Llamamos al metodo 'addLast'. 
.CODE
; Retorno de expresion del metodo 'add' de la clase 'IntLinkedList'
STORE 6  ; Almacenamos el retorno del metodo 'add' de la clase 'IntLinkedList'. 
FMEM 3  ; Liberamos el espacio usado por las variables locales del metodo 'add' de la clase 'IntLinkedList'. 
STOREFP  ; Actualizamos el FP para que apunte al RA del llamador 
RET 3  ; Retornamos de la unidad liberando el espacio que ocupaban los parametros y el THIS del metodo 'add' de la clase 'IntLinkedList'. 
L_ENDIFTHEN_3_add_IntLinkedList: NOP
.CODE
RMEM 1  ; Llamada al constructor de la clase 'IntElement'. Se reserva memoria para la referencia al nuevo CIR 
PUSH 3  ; Se apila la cantidad de variables de instancia del nuevo CIR mas el espacio para la VT. 
PUSH L_SIMPLE_MALLOC  ; Se apila la direccion de la rutina para reservar memoria en el heap 
CALL  ; Se invoca a la rutina en el tope de la pila (lsimple_malloc) 
DUP  ; Se duplica la referencia al nuevo CIR para el STOREREF. 
PUSH VT_IntElement  ; Apilamos la direccion del comienzo de la VT del id en la creacion de un CIR 
STOREREF 0  ; Guardamos las referencia a la VT en el CIR creado. El offset 0 en el CIR se corresponde a la VT 
DUP  ; Se duplica el THIS para el RA del constructor quedando, al finalizar la ejecucion, en el tope de la pila 
.CODE
LOAD 4  ; Cargamos el parametro 'e'. 
.CODE
SWAP  ; Acomodamos el THIS cada vez que generamos el codigo para un parametro. 
.CODE
PUSH L_IntElement_IntElement  ; Se apila la direccion del constructor de la clase 'IntElement'. 
CALL  ; Se invoca a la rutina del constructor de la clase 'IntElement' 
.CODE
STORE -1  ; Asignacion. El lado izquierdo es una variable local del metodo 'add' 
.CODE
LOAD 3  ; Apilamos el THIS para poder acceder al CIR. 
LOADREF 3  ; Cargamos la variable de instancia 'first'. 
.CODE
RMEM 1  ; Reservamos una locacion de memoria para el resultado del metodo 'add' de la clase 'IntLinkedList' 
SWAP  ; Acomodamos el THIS haciendo un SWAP con RETVAL 
.CODE
DUP  ; Duplicamos la referencia al CIR para utilizarla en el LOADREF al asociar la VT para invocar al metodo 'getNext'. 
LOADREF 0  ; El offset de la VT en el CIR es siempre 0. Accedemos a la VT. 
LOADREF 2  ; Recuperamos la direccion del metodo 'getNext'. 
CALL  ; Llamamos al metodo 'getNext'. 
.CODE
STORE -2  ; Asignacion. El lado izquierdo es una variable local del metodo 'add' 
.CODE
PUSH 0
.CODE
STORE 0  ; Asignacion. El lado izquierdo es una variable local del metodo 'add' 
.CODE
L_WHILE_4_add_IntLinkedList: NOP
.CODE
LOAD 0  ; Cargamos la variable local 'i'. 
.CODE
LOAD 5  ; Cargamos el parametro 'index'. 
.CODE
LT
BF L_ENDWHILE_4_add_IntLinkedList
.CODE
LOAD -2  ; Cargamos la variable local 'current'. 
.CODE
RMEM 1  ; Reservamos una locacion de memoria para el resultado del metodo 'add' de la clase 'IntLinkedList' 
SWAP  ; Acomodamos el THIS haciendo un SWAP con RETVAL 
.CODE
DUP  ; Duplicamos la referencia al CIR para utilizarla en el LOADREF al asociar la VT para invocar al metodo 'getNext'. 
LOADREF 0  ; El offset de la VT en el CIR es siempre 0. Accedemos a la VT. 
LOADREF 2  ; Recuperamos la direccion del metodo 'getNext'. 
CALL  ; Llamamos al metodo 'getNext'. 
.CODE
STORE -2  ; Asignacion. El lado izquierdo es una variable local del metodo 'add' 
.CODE
LOAD 0  ; Cargamos la variable local 'i'. 
.CODE
PUSH 1
.CODE
ADD
.CODE
STORE 0  ; Asignacion. El lado izquierdo es una variable local del metodo 'add' 
JUMP L_WHILE_4_add_IntLinkedList
L_ENDWHILE_4_add_IntLinkedList: NOP
.CODE
LOAD -1  ; Cargamos la variable local 'element'. 
.CODE
.CODE
LOAD -2  ; Cargamos la variable local 'current'. 
.CODE
RMEM 1  ; Reservamos una locacion de memoria para el resultado del metodo 'add' de la clase 'IntLinkedList' 
SWAP  ; Acomodamos el THIS haciendo un SWAP con RETVAL 
.CODE
DUP  ; Duplicamos la referencia al CIR para utilizarla en el LOADREF al asociar la VT para invocar al metodo 'getNext'. 
LOADREF 0  ; El offset de la VT en el CIR es siempre 0. Accedemos a la VT. 
LOADREF 2  ; Recuperamos la direccion del metodo 'getNext'. 
CALL  ; Llamamos al metodo 'getNext'. 
SWAP  ; Acomodamos el THIS cada vez que generamos el codigo para un parametro. 
.CODE
DUP  ; Duplicamos la referencia al CIR para utilizarla en el LOADREF al asociar la VT para invocar al metodo 'setNext'. 
LOADREF 0  ; El offset de la VT en el CIR es siempre 0. Accedemos a la VT. 
LOADREF 0  ; Recuperamos la direccion del metodo 'setNext'. 
CALL  ; Llamamos al metodo 'setNext'. 
.CODE
LOAD -2  ; Cargamos la variable local 'current'. 
.CODE
.CODE
LOAD -1  ; Cargamos la variable local 'element'. 
SWAP  ; Acomodamos el THIS cada vez que generamos el codigo para un parametro. 
.CODE
DUP  ; Duplicamos la referencia al CIR para utilizarla en el LOADREF al asociar la VT para invocar al metodo 'setNext'. 
LOADREF 0  ; El offset de la VT en el CIR es siempre 0. Accedemos a la VT. 
LOADREF 0  ; Recuperamos la direccion del metodo 'setNext'. 
CALL  ; Llamamos al metodo 'setNext'. 
.CODE
LOAD 3  ; Apilamos el THIS para poder acceder al CIR. 
LOADREF 1  ; Cargamos la variable de instancia 'size'. 
.CODE
PUSH 1
.CODE
ADD
.CODE
LOAD 3  ; Asignacion. Apilamos THIS 
SWAP  ; Asignacion. Invertimos el orden del tope de la pila. STOREREF usa los parametros en orden inverso (CIR, valor). 
STOREREF 1  ; Asignacion. El lado izquierdo es una variable de instancia de la clase 'IntLinkedList'. 
.CODE
PUSH 1  ; Apilamos 'true' 
.CODE
; Retorno de expresion del metodo 'add' de la clase 'IntLinkedList'
STORE 6  ; Almacenamos el retorno del metodo 'add' de la clase 'IntLinkedList'. 
FMEM 3  ; Liberamos el espacio usado por las variables locales del metodo 'add' de la clase 'IntLinkedList'. 
STOREFP  ; Actualizamos el FP para que apunte al RA del llamador 
RET 3  ; Retornamos de la unidad liberando el espacio que ocupaban los parametros y el THIS del metodo 'add' de la clase 'IntLinkedList'. 
FMEM 3  ; Liberamos espacio para las variables locales del metodo 'add' 
STOREFP ; actualizar el FP para que apunte al RA del llamador
RET 3
.CODE
L_IntLinkedList_getFirst: LOADFP  ; Se guarda el enlace dinamico al RA llamador 
LOADSP  ; Se apila el lugar a donde comienza el RA de la unidad 
STOREFP  ; Se actualiza el FP con el valor del tope de la pila 
.CODE
LOAD 3  ; Apilamos el THIS para poder acceder al CIR. 
LOADREF 3  ; Cargamos la variable de instancia 'first'. 
.CODE
RMEM 1  ; Reservamos una locacion de memoria para el resultado del metodo 'getFirst' de la clase 'IntLinkedList' 
SWAP  ; Acomodamos el THIS haciendo un SWAP con RETVAL 
.CODE
DUP  ; Duplicamos la referencia al CIR para utilizarla en el LOADREF al asociar la VT para invocar al metodo 'getElement'. 
LOADREF 0  ; El offset de la VT en el CIR es siempre 0. Accedemos a la VT. 
LOADREF 1  ; Recuperamos la direccion del metodo 'getElement'. 
CALL  ; Llamamos al metodo 'getElement'. 
.CODE
; Retorno de expresion del metodo 'getFirst' de la clase 'IntLinkedList'
STORE 4  ; Almacenamos el retorno del metodo 'getFirst' de la clase 'IntLinkedList'. 
STOREFP  ; Actualizamos el FP para que apunte al RA del llamador 
RET 1  ; Retornamos de la unidad liberando el espacio que ocupaban los parametros y el THIS del metodo 'getFirst' de la clase 'IntLinkedList'. 
STOREFP ; actualizar el FP para que apunte al RA del llamador
RET 1
.CODE
L_IntLinkedList_getLast: LOADFP  ; Se guarda el enlace dinamico al RA llamador 
LOADSP  ; Se apila el lugar a donde comienza el RA de la unidad 
STOREFP  ; Se actualiza el FP con el valor del tope de la pila 
.CODE
LOAD 3  ; Apilamos el THIS para poder acceder al CIR. 
LOADREF 2  ; Cargamos la variable de instancia 'last'. 
.CODE
RMEM 1  ; Reservamos una locacion de memoria para el resultado del metodo 'getLast' de la clase 'IntLinkedList' 
SWAP  ; Acomodamos el THIS haciendo un SWAP con RETVAL 
.CODE
DUP  ; Duplicamos la referencia al CIR para utilizarla en el LOADREF al asociar la VT para invocar al metodo 'getElement'. 
LOADREF 0  ; El offset de la VT en el CIR es siempre 0. Accedemos a la VT. 
LOADREF 1  ; Recuperamos la direccion del metodo 'getElement'. 
CALL  ; Llamamos al metodo 'getElement'. 
.CODE
; Retorno de expresion del metodo 'getLast' de la clase 'IntLinkedList'
STORE 4  ; Almacenamos el retorno del metodo 'getLast' de la clase 'IntLinkedList'. 
STOREFP  ; Actualizamos el FP para que apunte al RA del llamador 
RET 1  ; Retornamos de la unidad liberando el espacio que ocupaban los parametros y el THIS del metodo 'getLast' de la clase 'IntLinkedList'. 
STOREFP ; actualizar el FP para que apunte al RA del llamador
RET 1
.CODE
L_IntLinkedList_get: LOADFP  ; Se guarda el enlace dinamico al RA llamador 
LOADSP  ; Se apila el lugar a donde comienza el RA de la unidad 
STOREFP  ; Se actualiza el FP con el valor del tope de la pila 
RMEM 2  ; Reservamos espacio para las variables locales del metodo 'get' 
.CODE
LOAD 3  ; Apilamos el THIS para poder acceder al CIR. 
LOADREF 3  ; Cargamos la variable de instancia 'first'. 
.CODE
RMEM 1  ; Reservamos una locacion de memoria para el resultado del metodo 'get' de la clase 'IntLinkedList' 
SWAP  ; Acomodamos el THIS haciendo un SWAP con RETVAL 
.CODE
DUP  ; Duplicamos la referencia al CIR para utilizarla en el LOADREF al asociar la VT para invocar al metodo 'getNext'. 
LOADREF 0  ; El offset de la VT en el CIR es siempre 0. Accedemos a la VT. 
LOADREF 2  ; Recuperamos la direccion del metodo 'getNext'. 
CALL  ; Llamamos al metodo 'getNext'. 
.CODE
STORE -1  ; Asignacion. El lado izquierdo es una variable local del metodo 'get' 
.CODE
PUSH 0
.CODE
STORE 0  ; Asignacion. El lado izquierdo es una variable local del metodo 'get' 
.CODE
L_WHILE_5_get_IntLinkedList: NOP
.CODE
LOAD 0  ; Cargamos la variable local 'i'. 
.CODE
LOAD 4  ; Cargamos el parametro 'index'. 
.CODE
LT
BF L_ENDWHILE_5_get_IntLinkedList
.CODE
LOAD -1  ; Cargamos la variable local 'current'. 
.CODE
RMEM 1  ; Reservamos una locacion de memoria para el resultado del metodo 'get' de la clase 'IntLinkedList' 
SWAP  ; Acomodamos el THIS haciendo un SWAP con RETVAL 
.CODE
DUP  ; Duplicamos la referencia al CIR para utilizarla en el LOADREF al asociar la VT para invocar al metodo 'getNext'. 
LOADREF 0  ; El offset de la VT en el CIR es siempre 0. Accedemos a la VT. 
LOADREF 2  ; Recuperamos la direccion del metodo 'getNext'. 
CALL  ; Llamamos al metodo 'getNext'. 
.CODE
STORE -1  ; Asignacion. El lado izquierdo es una variable local del metodo 'get' 
.CODE
LOAD 0  ; Cargamos la variable local 'i'. 
.CODE
PUSH 1
.CODE
ADD
.CODE
STORE 0  ; Asignacion. El lado izquierdo es una variable local del metodo 'get' 
JUMP L_WHILE_5_get_IntLinkedList
L_ENDWHILE_5_get_IntLinkedList: NOP
.CODE
LOAD -1  ; Cargamos la variable local 'current'. 
.CODE
RMEM 1  ; Reservamos una locacion de memoria para el resultado del metodo 'get' de la clase 'IntLinkedList' 
SWAP  ; Acomodamos el THIS haciendo un SWAP con RETVAL 
.CODE
DUP  ; Duplicamos la referencia al CIR para utilizarla en el LOADREF al asociar la VT para invocar al metodo 'getElement'. 
LOADREF 0  ; El offset de la VT en el CIR es siempre 0. Accedemos a la VT. 
LOADREF 1  ; Recuperamos la direccion del metodo 'getElement'. 
CALL  ; Llamamos al metodo 'getElement'. 
.CODE
; Retorno de expresion del metodo 'get' de la clase 'IntLinkedList'
STORE 5  ; Almacenamos el retorno del metodo 'get' de la clase 'IntLinkedList'. 
FMEM 2  ; Liberamos el espacio usado por las variables locales del metodo 'get' de la clase 'IntLinkedList'. 
STOREFP  ; Actualizamos el FP para que apunte al RA del llamador 
RET 2  ; Retornamos de la unidad liberando el espacio que ocupaban los parametros y el THIS del metodo 'get' de la clase 'IntLinkedList'. 
FMEM 2  ; Liberamos espacio para las variables locales del metodo 'get' 
STOREFP ; actualizar el FP para que apunte al RA del llamador
RET 2
.DATA
VT_IntElement: DW L_IntElement_setNext ,L_IntElement_getElement ,L_IntElement_getNext 
.CODE
L_IntElement_IntElement: LOADFP  ; Se guarda el enlace dinamico al RA llamador 
LOADSP  ; Se apila el lugar a donde comienza el RA de la unidad 
STOREFP  ; Se actualiza el FP con el valor del tope de la pila 
.CODE
LOAD 4  ; Cargamos el parametro 'e'. 
.CODE
LOAD 3  ; Asignacion. Apilamos THIS 
SWAP  ; Asignacion. Invertimos el orden del tope de la pila. STOREREF usa los parametros en orden inverso (CIR, valor). 
STOREREF 1  ; Asignacion. El lado izquierdo es una variable de instancia de la clase 'IntElement'. 
STOREFP ; actualizar el FP para que apunte al RA del llamador
RET 2
.CODE
L_IntElement_setNext: LOADFP  ; Se guarda el enlace dinamico al RA llamador 
LOADSP  ; Se apila el lugar a donde comienza el RA de la unidad 
STOREFP  ; Se actualiza el FP con el valor del tope de la pila 
.CODE
LOAD 4  ; Cargamos el parametro 'n'. 
.CODE
LOAD 3  ; Asignacion. Apilamos THIS 
SWAP  ; Asignacion. Invertimos el orden del tope de la pila. STOREREF usa los parametros en orden inverso (CIR, valor). 
STOREREF 2  ; Asignacion. El lado izquierdo es una variable de instancia de la clase 'IntElement'. 
STOREFP ; actualizar el FP para que apunte al RA del llamador
RET 2
.CODE
L_IntElement_getElement: LOADFP  ; Se guarda el enlace dinamico al RA llamador 
LOADSP  ; Se apila el lugar a donde comienza el RA de la unidad 
STOREFP  ; Se actualiza el FP con el valor del tope de la pila 
.CODE
LOAD 3  ; Apilamos el THIS para poder acceder al CIR. 
LOADREF 1  ; Cargamos la variable de instancia 'element'. 
.CODE
; Retorno de expresion del metodo 'getElement' de la clase 'IntElement'
STORE 4  ; Almacenamos el retorno del metodo 'getElement' de la clase 'IntElement'. 
STOREFP  ; Actualizamos el FP para que apunte al RA del llamador 
RET 1  ; Retornamos de la unidad liberando el espacio que ocupaban los parametros y el THIS del metodo 'getElement' de la clase 'IntElement'. 
STOREFP ; actualizar el FP para que apunte al RA del llamador
RET 1
.CODE
L_IntElement_getNext: LOADFP  ; Se guarda el enlace dinamico al RA llamador 
LOADSP  ; Se apila el lugar a donde comienza el RA de la unidad 
STOREFP  ; Se actualiza el FP con el valor del tope de la pila 
.CODE
LOAD 3  ; Apilamos el THIS para poder acceder al CIR. 
LOADREF 2  ; Cargamos la variable de instancia 'next'. 
.CODE
; Retorno de expresion del metodo 'getNext' de la clase 'IntElement'
STORE 4  ; Almacenamos el retorno del metodo 'getNext' de la clase 'IntElement'. 
STOREFP  ; Actualizamos el FP para que apunte al RA del llamador 
RET 1  ; Retornamos de la unidad liberando el espacio que ocupaban los parametros y el THIS del metodo 'getNext' de la clase 'IntElement'. 
STOREFP ; actualizar el FP para que apunte al RA del llamador
RET 1
.DATA
VT_MainClass: DW L_MainClass_main 
.CODE
L_MainClass_MainClass: LOADFP  ; Se guarda el enlace dinamico al RA llamador 
LOADSP  ; Se apila el lugar a donde comienza el RA de la unidad 
STOREFP  ; Se actualiza el FP con el valor del tope de la pila 
STOREFP ; actualizar el FP para que apunte al RA del llamador
RET 1
.CODE
L_MainClass_main: LOADFP  ; Se guarda el enlace dinamico al RA llamador 
LOADSP  ; Se apila el lugar a donde comienza el RA de la unidad 
STOREFP  ; Se actualiza el FP con el valor del tope de la pila 
RMEM 2  ; Reservamos espacio para las variables locales del metodo 'main' 
.CODE
RMEM 1  ; Llamada al constructor de la clase 'IntLinkedList'. Se reserva memoria para la referencia al nuevo CIR 
PUSH 4  ; Se apila la cantidad de variables de instancia del nuevo CIR mas el espacio para la VT. 
PUSH L_SIMPLE_MALLOC  ; Se apila la direccion de la rutina para reservar memoria en el heap 
CALL  ; Se invoca a la rutina en el tope de la pila (lsimple_malloc) 
DUP  ; Se duplica la referencia al nuevo CIR para el STOREREF. 
PUSH VT_IntLinkedList  ; Apilamos la direccion del comienzo de la VT del id en la creacion de un CIR 
STOREREF 0  ; Guardamos las referencia a la VT en el CIR creado. El offset 0 en el CIR se corresponde a la VT 
DUP  ; Se duplica el THIS para el RA del constructor quedando, al finalizar la ejecucion, en el tope de la pila 
.CODE
PUSH L_IntLinkedList_IntLinkedList  ; Se apila la direccion del constructor de la clase 'IntLinkedList'. 
CALL  ; Se invoca a la rutina del constructor de la clase 'IntLinkedList' 
.CODE
STORE -1  ; Asignacion. El lado izquierdo es una variable local del metodo 'main' 
.CODE
LOAD -1  ; Cargamos la variable local 'list'. 
.CODE
RMEM 1  ; Reservamos una locacion de memoria para el resultado del metodo 'main' de la clase 'MainClass' 
SWAP  ; Acomodamos el THIS haciendo un SWAP con RETVAL 
.CODE
PUSH 0
SWAP  ; Acomodamos el THIS cada vez que generamos el codigo para un parametro. 
.CODE
DUP  ; Duplicamos la referencia al CIR para utilizarla en el LOADREF al asociar la VT para invocar al metodo 'addFirst'. 
LOADREF 0  ; El offset de la VT en el CIR es siempre 0. Accedemos a la VT. 
LOADREF 1  ; Recuperamos la direccion del metodo 'addFirst'. 
CALL  ; Llamamos al metodo 'addFirst'. 
POP  ; Desapilamos el resultado de la expresion 
.CODE
LOAD -1  ; Cargamos la variable local 'list'. 
.CODE
RMEM 1  ; Reservamos una locacion de memoria para el resultado del metodo 'main' de la clase 'MainClass' 
SWAP  ; Acomodamos el THIS haciendo un SWAP con RETVAL 
.CODE
PUSH 1
SWAP  ; Acomodamos el THIS cada vez que generamos el codigo para un parametro. 
.CODE
DUP  ; Duplicamos la referencia al CIR para utilizarla en el LOADREF al asociar la VT para invocar al metodo 'addLast'. 
LOADREF 0  ; El offset de la VT en el CIR es siempre 0. Accedemos a la VT. 
LOADREF 2  ; Recuperamos la direccion del metodo 'addLast'. 
CALL  ; Llamamos al metodo 'addLast'. 
POP  ; Desapilamos el resultado de la expresion 
.CODE
LOAD -1  ; Cargamos la variable local 'list'. 
.CODE
RMEM 1  ; Reservamos una locacion de memoria para el resultado del metodo 'main' de la clase 'MainClass' 
SWAP  ; Acomodamos el THIS haciendo un SWAP con RETVAL 
.CODE
PUSH 2
SWAP  ; Acomodamos el THIS cada vez que generamos el codigo para un parametro. 
.CODE
DUP  ; Duplicamos la referencia al CIR para utilizarla en el LOADREF al asociar la VT para invocar al metodo 'addLast'. 
LOADREF 0  ; El offset de la VT en el CIR es siempre 0. Accedemos a la VT. 
LOADREF 2  ; Recuperamos la direccion del metodo 'addLast'. 
CALL  ; Llamamos al metodo 'addLast'. 
POP  ; Desapilamos el resultado de la expresion 
.CODE
LOAD -1  ; Cargamos la variable local 'list'. 
.CODE
RMEM 1  ; Reservamos una locacion de memoria para el resultado del metodo 'main' de la clase 'MainClass' 
SWAP  ; Acomodamos el THIS haciendo un SWAP con RETVAL 
.CODE
PUSH 3
SWAP  ; Acomodamos el THIS cada vez que generamos el codigo para un parametro. 
.CODE
DUP  ; Duplicamos la referencia al CIR para utilizarla en el LOADREF al asociar la VT para invocar al metodo 'addLast'. 
LOADREF 0  ; El offset de la VT en el CIR es siempre 0. Accedemos a la VT. 
LOADREF 2  ; Recuperamos la direccion del metodo 'addLast'. 
CALL  ; Llamamos al metodo 'addLast'. 
POP  ; Desapilamos el resultado de la expresion 
.CODE
LOAD -1  ; Cargamos la variable local 'list'. 
.CODE
RMEM 1  ; Reservamos una locacion de memoria para el resultado del metodo 'main' de la clase 'MainClass' 
SWAP  ; Acomodamos el THIS haciendo un SWAP con RETVAL 
.CODE
PUSH 4
SWAP  ; Acomodamos el THIS cada vez que generamos el codigo para un parametro. 
.CODE
DUP  ; Duplicamos la referencia al CIR para utilizarla en el LOADREF al asociar la VT para invocar al metodo 'addLast'. 
LOADREF 0  ; El offset de la VT en el CIR es siempre 0. Accedemos a la VT. 
LOADREF 2  ; Recuperamos la direccion del metodo 'addLast'. 
CALL  ; Llamamos al metodo 'addLast'. 
POP  ; Desapilamos el resultado de la expresion 
.CODE
LOAD -1  ; Cargamos la variable local 'list'. 
.CODE
RMEM 1  ; Reservamos una locacion de memoria para el resultado del metodo 'main' de la clase 'MainClass' 
SWAP  ; Acomodamos el THIS haciendo un SWAP con RETVAL 
.CODE
PUSH 5
SWAP  ; Acomodamos el THIS cada vez que generamos el codigo para un parametro. 
.CODE
DUP  ; Duplicamos la referencia al CIR para utilizarla en el LOADREF al asociar la VT para invocar al metodo 'addLast'. 
LOADREF 0  ; El offset de la VT en el CIR es siempre 0. Accedemos a la VT. 
LOADREF 2  ; Recuperamos la direccion del metodo 'addLast'. 
CALL  ; Llamamos al metodo 'addLast'. 
POP  ; Desapilamos el resultado de la expresion 
.CODE
.CODE
PUSH 0
.CODE
STORE 0  ; Asignacion. El lado izquierdo es una variable local del metodo 'main' 
L_COND_FOR_6_main_MainClass: NOP
.CODE
LOAD 0  ; Cargamos la variable local 'i'. 
.CODE
LOAD -1  ; Cargamos la variable local 'list'. 
.CODE
RMEM 1  ; Reservamos una locacion de memoria para el resultado del metodo 'main' de la clase 'MainClass' 
SWAP  ; Acomodamos el THIS haciendo un SWAP con RETVAL 
.CODE
DUP  ; Duplicamos la referencia al CIR para utilizarla en el LOADREF al asociar la VT para invocar al metodo 'getSize'. 
LOADREF 0  ; El offset de la VT en el CIR es siempre 0. Accedemos a la VT. 
LOADREF 0  ; Recuperamos la direccion del metodo 'getSize'. 
CALL  ; Llamamos al metodo 'getSize'. 
.CODE
LT
BF L_ENDFOR_6_main_MainClass
.CODE
PUSH VT_System
.CODE
LOAD 0  ; Cargamos la variable local 'i'. 
.CODE
PUSH 1
.CODE
ADD
STORE 0  ; For. Asignacion. El lado izquierdo es una variable local del metodo 'main' 
JUMP L_COND_FOR_6_main_MainClass
L_ENDFOR_6_main_MainClass: NOP
FMEM 2  ; Liberamos espacio para las variables locales del metodo 'main' 
STOREFP ; actualizar el FP para que apunte al RA del llamador
RET 1
