.DATA
VT_Object: NOP
VT_System: DW lCtorSystem, lMetSystem_printI, lMetSystem_read, lMetSystem_printC, lMetSystem_printB, lMetSystem_printS, lMetSystem_println, lMetSystem_printBln, lMetSystem_printCln, lMetSystem_printIln, lMetSystem_printSln 
.CODE
PUSH lsimple_init_heap  ; inicializacion de heap 
CALL
RMEM 1  ; Se reserva memoria para el this 
PUSH lMetB_main
CALL
HALT
lCtorSystem: NOP  ; Constructor de la Clase System 
LOADFP
LOADSP
STOREFP
STOREFP
RET 1
lMetSystem_printI: NOP
LOADFP
LOADSP
STOREFP
LOAD 4
IPRINT
STOREFP
RET 2
lMetSystem_read: NOP
LOADFP
LOADSP
STOREFP
READ
STORE 4
STOREFP
RET 1
lMetSystem_printC: NOP
LOADFP
LOADSP
STOREFP
LOAD 4
CPRINT
STOREFP
RET 2
lMetSystem_printB: NOP
LOADFP
LOADSP
STOREFP
LOAD 4
BPRINT
STOREFP
RET 2
lMetSystem_printS: NOP
LOADFP
LOADSP
STOREFP
LOAD 4
SPRINT
STOREFP
RET 2
lMetSystem_println: NOP
LOADFP
LOADSP
STOREFP
PRNLN
STOREFP
RET 1
lMetSystem_printBln: NOP
LOADFP
LOADSP
STOREFP
LOAD 4
BPRINT
PRNLN
STOREFP
RET 2
lMetSystem_printCln: NOP
LOADFP
LOADSP
STOREFP
LOAD 4
CPRINT
PRNLN
STOREFP
RET 2
lMetSystem_printIln: NOP
LOADFP
LOADSP
STOREFP
LOAD 4
IPRINT
PRNLN
STOREFP
RET 2
lMetSystem_printSln: NOP
LOADFP
LOADSP
STOREFP
LOAD 4
SPRINT
PRNLN
STOREFP
RET 2
lsimple_malloc: LOADFP  ; Inicializacion unidad 
LOADSP
STOREFP  ; Finaliza inicializacion del RA 
LOADHL  ; hl 
DUP  ; hl 
PUSH 1  ; 1 
ADD  ; hl+1 
STORE 4  ; Guarda resultado (puntero a la base del bloque) 
LOAD 3  ; Carga cantidad de celdas a alojar (parametro)  
ADD
STOREHL  ; Mueve el heap limit (hl) 
STOREFP
RET 1  ; Retorna eliminando el parametro 
lsimple_init_heap: RET 0  ; Inicializacion simplificada del .heap 
.DATA
VT_A: DW lMetA_getN 
.CODE
; Inicializacion CI metodo 'A' de Clase 'A'
lMetA_A: LOADFP  ; Se guarda el enlace dinamico al RA llamador 
LOADSP  ; Se apila el lugar a donde comienza el RA de la unidad 
STOREFP  ; Se actualiza el FP con el valor del tope de la pila 
STOREFP ; actualizar el FP para que apunte al RA del llamador
RET 1
.CODE
; Inicializacion CI metodo 'getN' de Clase 'A'
lMetA_getN: LOADFP  ; Se guarda el enlace dinamico al RA llamador 
LOADSP  ; Se apila el lugar a donde comienza el RA de la unidad 
STOREFP  ; Se actualiza el FP con el valor del tope de la pila 
.CODE
PUSH 10
.CODE
LOAD 3  ; Apilamos this - Asignacion lado izquierdo variable de instancia 
SWAP  ; Invertimos orden dado que STOREREF usa los parametros en orden inverso (CIR, valor) - Asignacion variable de instancia 
STOREREF 1  ; Asignacion con lado izquierdo: variable de instancia 'n' 
.CODE
LOAD 3  ; APILAMOS THIS PARA PODER ACCEDER AL CIR 
LOADREF 1  ; Accedemos a la variable de instancia 'n' 
.CODE
; Codigo Retorno Metodo 'getN' dado por un 'return expresion;'
STORE 4  ; Se almacena el resultado en RetVal del metodo 'getN' 
STOREFP  ; Se actualiza el FP para que apunte al RA del llamador 
RET 1  ; Se retorna la unidad liberando el espacio asociado a los parametros + 1(this) en metodo 'getN' 
STOREFP ; actualizar el FP para que apunte al RA del llamador
RET 1
.DATA
VT_C: DW lMetB_getN ,lMetB_main ,lMetB_printN ,lMetB_setValue ,lMetC_setValueInB 
.CODE
; Inicializacion CI metodo 'setValueInB' de Clase 'C'
lMetC_setValueInB: LOADFP  ; Se guarda el enlace dinamico al RA llamador 
LOADSP  ; Se apila el lugar a donde comienza el RA de la unidad 
STOREFP  ; Se actualiza el FP con el valor del tope de la pila 
.CODE
LOAD 3  ; Apilamos this para poder invocar al metodo 'setValue' 
.CODE
LOAD 4  ; Accedemos al argumento formal 'value' 
SWAP  ; Seguimos bajando el futuro this por cada parametro del metodo 'setValue' 
DUP  ; Duplicamos referencia al CIR para utilizarla en LOADREF para asociar la VT para invocar al metodo 'setValue' 
LOADREF 0  ; El offset de la VT es siempre 0 en el CIR, accedemos a la VT 
LOADREF 3  ; Recuperamos la direccion del metodo actual 'setValue' 
CALL  ; Llamada al metodo 'setValue' cuya direccion esta en el tope de la pila 
STOREFP ; actualizar el FP para que apunte al RA del llamador
RET 2
.CODE
; Inicializacion CI metodo 'C' de Clase 'C'
lMetC_C: LOADFP  ; Se guarda el enlace dinamico al RA llamador 
LOADSP  ; Se apila el lugar a donde comienza el RA de la unidad 
STOREFP  ; Se actualiza el FP con el valor del tope de la pila 
STOREFP ; actualizar el FP para que apunte al RA del llamador
RET 1
.DATA
VT_B: DW lMetB_getN ,lMetB_main ,lMetB_printN ,lMetB_setValue 
.CODE
; Inicializacion CI metodo 'main' de Clase 'B'
lMetB_main: LOADFP  ; Se guarda el enlace dinamico al RA llamador 
LOADSP  ; Se apila el lugar a donde comienza el RA de la unidad 
STOREFP  ; Se actualiza el FP con el valor del tope de la pila 
RMEM 1  ; Reservamos espacio para las variables locales del metodo 'main' 
.CODE
RMEM 1  ; Se reserva memoria para la referencia al nuevo CIR - Uso del Ctor de Clase 'B' 
PUSH 3  ; Se apila la cantidad de variables de instancia del nuevo CIR +1 (espacio para la VT) - Ctor de Clase 'B' 
PUSH lsimple_malloc  ; Se apila la direccion de la rutina para alojar memoria en el heap : malloc - Ctor de Clase 'B' 
CALL  ; Se invoca a la rutina malloc que reserva espacio en el heap 
DUP  ; Se duplica referencia al nuevo CIR para que lo use STOREREF - Ctor de Clase 'B' 
PUSH VT_B  ; Apilamos la direccion del comienzo de la VT del id en la creacion de un CIR 
STOREREF 0  ; Guardamos la Referencia a la VT en el CIR que creamos, por convencion el offset 0 en el CIR se corresponde a la VT 
DUP  ; Se duplica el this para el RA del Constructor quedando al finalizar la ejecucion en el tope de la pila 
.CODE
PUSH lMetB_B  ; Se apila la direccion del Ctor de Clase 'B' 
CALL  ; Se invoca a la rutina del Ctor de Clase 'B' 
.CODE
STORE 0  ; Asignacion con lado izquierdo: variable local del metodo 'objetoB' 
.CODE
LOAD 0  ; Accedemos a la variable local 'objetoB' 
.CODE
.CODE
DUP  ; Duplicamos referencia al CIR para utilizarla en LOADREF para asociar la VT para invocar al metodo 'printN' 
LOADREF 0  ; El offset de la VT es siempre 0 en el CIR, accedemos a la VT  
LOADREF 2  ; Recuperamos la dir del metodo actual 'printN' 
CALL  ; Llamada al metodo 'printN' cuya direccion esta en el tope de la pila 
FMEM 1  ; Liberamos espacio para las variables locales del metodo 'main' 
STOREFP ; actualizar el FP para que apunte al RA del llamador
RET 1
.CODE
; Inicializacion CI metodo 'getN' de Clase 'B'
lMetB_getN: LOADFP  ; Se guarda el enlace dinamico al RA llamador 
LOADSP  ; Se apila el lugar a donde comienza el RA de la unidad 
STOREFP  ; Se actualiza el FP con el valor del tope de la pila 
.CODE
PUSH 123
.CODE
; Codigo Retorno Metodo 'getN' dado por un 'return expresion;'
STORE 4  ; Se almacena el resultado en RetVal del metodo 'getN' 
STOREFP  ; Se actualiza el FP para que apunte al RA del llamador 
RET 1  ; Se retorna la unidad liberando el espacio asociado a los parametros + 1(this) en metodo 'getN' 
STOREFP ; actualizar el FP para que apunte al RA del llamador
RET 1
.CODE
; Inicializacion CI metodo 'printN' de Clase 'B'
lMetB_printN: LOADFP  ; Se guarda el enlace dinamico al RA llamador 
LOADSP  ; Se apila el lugar a donde comienza el RA de la unidad 
STOREFP  ; Se actualiza el FP con el valor del tope de la pila 
RMEM 1  ; Reservamos espacio para las variables locales del metodo 'printN' 
.CODE
LOAD 3  ; Apilamos this para poder invocar al metodo 'getN' 
RMEM 1  ; Reservamos una locacion de memoria para el resultado del metodo 'getN': RetVal 
SWAP  ; Se lleva al futuro THIS al lugar adecuado haciendo un SWAP con el RetVal 
DUP  ; Duplicamos referencia al CIR para utilizarla en LOADREF para asociar la VT para invocar al metodo 'getN' 
LOADREF 0  ; El offset de la VT es siempre 0 en el CIR, accedemos a la VT 
LOADREF 0  ; Recuperamos la direccion del metodo actual 'getN' 
CALL  ; Llamada al metodo 'getN' cuya direccion esta en el tope de la pila 
.CODE
.CODE
STORE 0  ; Asignacion con lado izquierdo: variable local del metodo 'num' 
.CODE
RMEM 1 ;Reservamos una locacion de memoria para el this ficticio
.CODE
.CODE
LOAD 0  ; Accedemos a la variable local 'num' 
SWAP  ; Por cada parametro hacemos un SWAP del futuro THIS para bajarlo al lugar adecuado, metodo 'printI' 
.CODE
PUSH lMetSystem_printI
CALL  ; Llamada al metodo 'printI' de Clase System cuya direccion esta en el tope de la pila 
FMEM 1  ; Liberamos espacio para las variables locales del metodo 'printN' 
STOREFP ; actualizar el FP para que apunte al RA del llamador
RET 1
.CODE
; Inicializacion CI metodo 'setValue' de Clase 'B'
lMetB_setValue: LOADFP  ; Se guarda el enlace dinamico al RA llamador 
LOADSP  ; Se apila el lugar a donde comienza el RA de la unidad 
STOREFP  ; Se actualiza el FP con el valor del tope de la pila 
.CODE
LOAD 4  ; Accedemos al argumento formal 'value' 
.CODE
LOAD 3  ; Apilamos this - Asignacion lado izquierdo variable de instancia 
SWAP  ; Invertimos orden dado que STOREREF usa los parametros en orden inverso (CIR, valor) - Asignacion variable de instancia 
STOREREF 2  ; Asignacion con lado izquierdo: variable de instancia 'num' 
STOREFP ; actualizar el FP para que apunte al RA del llamador
RET 2
.CODE
; Inicializacion CI metodo 'B' de Clase 'B'
lMetB_B: LOADFP  ; Se guarda el enlace dinamico al RA llamador 
LOADSP  ; Se apila el lugar a donde comienza el RA de la unidad 
STOREFP  ; Se actualiza el FP con el valor del tope de la pila 
STOREFP ; actualizar el FP para que apunte al RA del llamador
RET 1
