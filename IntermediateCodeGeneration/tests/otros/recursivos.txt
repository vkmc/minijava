.DATA
VT_Object: NOP
VT_System: DW L_MET_System_Ctor, L_MET_System_read, L_MET_System_printI, L_MET_System_printC, L_MET_System_printB, L_MET_System_printS, L_MET_System_println, L_MET_System_printBln, L_MET_System_printCln, L_MET_System_printIln, L_MET_System_printSln 
.CODE
PUSH L_SIMPLE_INIT_HEAP  ; Inicializamos el heap 
CALL
RMEM 1  ; Reservamos memoria para el this 
PUSH L_MET_recursivos_main  ; Apilamos el label del main de la Clase Principal del Programa 
CALL
HALT
L_MET_System_Ctor: NOP  ; Constructor de system 
LOADFP
LOADSP
STOREFP
STOREFP
RET 1
L_MET_System_read: NOP
LOADFP
LOADSP
STOREFP
READ
STORE 4
STOREFP
RET 1
L_MET_System_printI: NOP
LOADFP
LOADSP
STOREFP
LOAD 4
IPRINT
STOREFP
RET 2
L_MET_System_printC: NOP
LOADFP
LOADSP
STOREFP
LOAD 4
CPRINT
STOREFP
RET 2
L_MET_System_printB: NOP
LOADFP
LOADSP
STOREFP
LOAD 4
BPRINT
STOREFP
RET 2
L_MET_System_printS: NOP
LOADFP
LOADSP
STOREFP
LOAD 4
SPRINT
STOREFP
RET 2
L_MET_System_println: NOP
LOADFP
LOADSP
STOREFP
PRNLN
STOREFP
RET 1
L_MET_System_printBln: NOP
LOADFP
LOADSP
STOREFP
LOAD 4
BPRINT
PRNLN
STOREFP
RET 2
L_MET_System_printCln: NOP
LOADFP
LOADSP
STOREFP
LOAD 4
CPRINT
PRNLN
STOREFP
RET 2
L_MET_System_printIln: NOP
LOADFP
LOADSP
STOREFP
LOAD 4
IPRINT
PRNLN
STOREFP
RET 2
L_MET_System_printSln: NOP
LOADFP
LOADSP
STOREFP
LOAD 4
SPRINT
PRNLN
STOREFP
RET 2
L_SIMPLE_MALLOC: LOADFP  ; Inicializacion unidad 
LOADSP
STOREFP  ; Finaliza inicializacion del RA 
LOADHL  ; hl 
DUP  ; hl 
PUSH 1  ; 1 
ADD  ; hl+1 
STORE 4  ; Guarda resultado (puntero a la base del bloque) 
LOAD 3  ; Carga cantidad de celdas a alojar (parametro)  
ADD
STOREHL  ; Mueve el heap limit (hl) 
STOREFP
RET 1  ; Retorna eliminando el parametro 
L_SIMPLE_INIT_HEAP: RET 0  ; Inicializacion simplificada del .heap 
.DATA
VT_recursivos: DW L_MET_recursivos_fibonacci, L_MET_recursivos_sumatoria, L_MET_recursivos_factorial, L_MET_recursivos_main
.CODE
; INICIALIZAMOS EL CI DEL CONSTRUCTOR 'recursivos' DE LA CLASE 'recursivos'
L_CTOR_recursivos_recursivos: LOADFP  ; Guardamos el ED al RA llamador 
LOADSP  ; Apilamos la locación donde empieza el RA de la unidad 
STOREFP  ; Actualizamos el FP con el valor del tope de la pila 
STOREFP ; Se actualiza el FP para que apunte al RA del llamador
RET 1  ; Retornamos de la unidad 
.CODE
; INICIALIZAMOS EL CI DEL METODO 'fibonacci' DE LA CLASE 'recursivos'
L_MET_recursivos_fibonacci: LOADFP  ; Guardamos el ED al RA llamador 
LOADSP  ; Apilamos la locación donde empieza el RA de la unidad 
STOREFP  ; Actualizamos el FP con el valor del tope de la pila 
.CODE
LOAD 4  ; Cargamos el parametro 'n'. 
.CODE
PUSH 0
.CODE
GT
.CODE
LOAD 4  ; Cargamos el parametro 'n'. 
.CODE
PUSH 3
.CODE
LT
.CODE
AND
.CODE
BF L_ENDIFTHEN_1_fibonacci_recursivos
.CODE
PUSH 1
.CODE
; Retorno de expresion del metodo 'fibonacci' de la clase 'recursivos'
STORE 5  ; Almacenamos el retorno del metodo 'fibonacci' de la clase 'recursivos'. 
STOREFP  ; Actualizamos el FP para que apunte al RA del llamador 
RET 2  ; Retornamos de la unidad liberando el espacio que ocupaban los parametros y el THIS del metodo 'fibonacci' de la clase 'recursivos'. 
L_ENDIFTHEN_1_fibonacci_recursivos: NOP
.CODE
LOAD 3  ; Apilamos el THIS para invocar al metodo 'fibonacci' 
RMEM 1  ; Reservamos una locacion de memoria para el resultado del metodo 'fibonacci' de la clase 'recursivos'. 
SWAP  ; Acomodamos el THIS haciendo un SWAP con RETVAL. 
.CODE
LOAD 4  ; Cargamos el parametro 'n'. 
.CODE
PUSH 1
.CODE
SUB
SWAP  ; Acomodamos el THIS cada vez que generamos el codigo para un parametro. 
PUSH VT_recursivos
LOADREF 0  ; MethodCallNode. Recuperamos la direccion del metodo 'fibonacci'. 
CALL  ; MethodCallNode. Llamamos al metodo 'fibonacci'. 
.CODE
LOAD 3  ; Apilamos el THIS para invocar al metodo 'fibonacci' 
RMEM 1  ; Reservamos una locacion de memoria para el resultado del metodo 'fibonacci' de la clase 'recursivos'. 
SWAP  ; Acomodamos el THIS haciendo un SWAP con RETVAL. 
.CODE
LOAD 4  ; Cargamos el parametro 'n'. 
.CODE
PUSH 2
.CODE
SUB
SWAP  ; Acomodamos el THIS cada vez que generamos el codigo para un parametro. 
PUSH VT_recursivos
LOADREF 0  ; MethodCallNode. Recuperamos la direccion del metodo 'fibonacci'. 
CALL  ; MethodCallNode. Llamamos al metodo 'fibonacci'. 
.CODE
ADD
.CODE
; Retorno de expresion del metodo 'fibonacci' de la clase 'recursivos'
STORE 5  ; Almacenamos el retorno del metodo 'fibonacci' de la clase 'recursivos'. 
STOREFP  ; Actualizamos el FP para que apunte al RA del llamador 
RET 2  ; Retornamos de la unidad liberando el espacio que ocupaban los parametros y el THIS del metodo 'fibonacci' de la clase 'recursivos'. 
STOREFP ; Se actualiza el FP para que apunte al RA del llamador
RET 2  ; Retornamos de la unidad 
.CODE
; INICIALIZAMOS EL CI DEL METODO 'sumatoria' DE LA CLASE 'recursivos'
L_MET_recursivos_sumatoria: LOADFP  ; Guardamos el ED al RA llamador 
LOADSP  ; Apilamos la locación donde empieza el RA de la unidad 
STOREFP  ; Actualizamos el FP con el valor del tope de la pila 
.CODE
LOAD 4  ; Cargamos el parametro 'n'. 
.CODE
PUSH 0
.CODE
EQ
.CODE
BF L_ENDIFTHEN_2_sumatoria_recursivos
.CODE
PUSH 0
.CODE
; Retorno de expresion del metodo 'sumatoria' de la clase 'recursivos'
STORE 5  ; Almacenamos el retorno del metodo 'sumatoria' de la clase 'recursivos'. 
STOREFP  ; Actualizamos el FP para que apunte al RA del llamador 
RET 2  ; Retornamos de la unidad liberando el espacio que ocupaban los parametros y el THIS del metodo 'sumatoria' de la clase 'recursivos'. 
L_ENDIFTHEN_2_sumatoria_recursivos: NOP
.CODE
LOAD 4  ; Cargamos el parametro 'n'. 
.CODE
LOAD 3  ; Apilamos el THIS para invocar al metodo 'sumatoria' 
RMEM 1  ; Reservamos una locacion de memoria para el resultado del metodo 'sumatoria' de la clase 'recursivos'. 
SWAP  ; Acomodamos el THIS haciendo un SWAP con RETVAL. 
.CODE
LOAD 4  ; Cargamos el parametro 'n'. 
.CODE
PUSH 1
.CODE
SUB
SWAP  ; Acomodamos el THIS cada vez que generamos el codigo para un parametro. 
PUSH VT_recursivos
LOADREF 1  ; MethodCallNode. Recuperamos la direccion del metodo 'sumatoria'. 
CALL  ; MethodCallNode. Llamamos al metodo 'sumatoria'. 
.CODE
ADD
.CODE
; Retorno de expresion del metodo 'sumatoria' de la clase 'recursivos'
STORE 5  ; Almacenamos el retorno del metodo 'sumatoria' de la clase 'recursivos'. 
STOREFP  ; Actualizamos el FP para que apunte al RA del llamador 
RET 2  ; Retornamos de la unidad liberando el espacio que ocupaban los parametros y el THIS del metodo 'sumatoria' de la clase 'recursivos'. 
STOREFP ; Se actualiza el FP para que apunte al RA del llamador
RET 2  ; Retornamos de la unidad 
.CODE
; INICIALIZAMOS EL CI DEL METODO 'factorial' DE LA CLASE 'recursivos'
L_MET_recursivos_factorial: LOADFP  ; Guardamos el ED al RA llamador 
LOADSP  ; Apilamos la locación donde empieza el RA de la unidad 
STOREFP  ; Actualizamos el FP con el valor del tope de la pila 
.CODE
LOAD 4  ; Cargamos el parametro 'n'. 
.CODE
PUSH 0
.CODE
EQ
.CODE
BF L_ENDIFTHEN_3_factorial_recursivos
.CODE
PUSH 1
.CODE
; Retorno de expresion del metodo 'factorial' de la clase 'recursivos'
STORE 5  ; Almacenamos el retorno del metodo 'factorial' de la clase 'recursivos'. 
STOREFP  ; Actualizamos el FP para que apunte al RA del llamador 
RET 2  ; Retornamos de la unidad liberando el espacio que ocupaban los parametros y el THIS del metodo 'factorial' de la clase 'recursivos'. 
L_ENDIFTHEN_3_factorial_recursivos: NOP
.CODE
LOAD 4  ; Cargamos el parametro 'n'. 
.CODE
LOAD 3  ; Apilamos el THIS para invocar al metodo 'factorial' 
RMEM 1  ; Reservamos una locacion de memoria para el resultado del metodo 'factorial' de la clase 'recursivos'. 
SWAP  ; Acomodamos el THIS haciendo un SWAP con RETVAL. 
.CODE
LOAD 4  ; Cargamos el parametro 'n'. 
.CODE
PUSH 1
.CODE
SUB
SWAP  ; Acomodamos el THIS cada vez que generamos el codigo para un parametro. 
PUSH VT_recursivos
LOADREF 2  ; MethodCallNode. Recuperamos la direccion del metodo 'factorial'. 
CALL  ; MethodCallNode. Llamamos al metodo 'factorial'. 
.CODE
MUL
.CODE
; Retorno de expresion del metodo 'factorial' de la clase 'recursivos'
STORE 5  ; Almacenamos el retorno del metodo 'factorial' de la clase 'recursivos'. 
STOREFP  ; Actualizamos el FP para que apunte al RA del llamador 
RET 2  ; Retornamos de la unidad liberando el espacio que ocupaban los parametros y el THIS del metodo 'factorial' de la clase 'recursivos'. 
STOREFP ; Se actualiza el FP para que apunte al RA del llamador
RET 2  ; Retornamos de la unidad 
.CODE
; INICIALIZAMOS EL CI DEL METODO 'main' DE LA CLASE 'recursivos'
L_MET_recursivos_main: LOADFP  ; Guardamos el ED al RA llamador 
LOADSP  ; Apilamos la locación donde empieza el RA de la unidad 
STOREFP  ; Actualizamos el FP con el valor del tope de la pila 
RMEM 2  ; Reservamos memoria para las variables locales del metodo 'main' 
.CODE
PUSH 7
.CODE
STORE 0  ; Asignacion. El lado izquierdo es una variable local del metodo 'main' 
.CODE
RMEM 1  ; Reservamos una locacion de memoria para el this ficticio 
.CODE
.CODE
LOAD 3  ; Apilamos el THIS para invocar al metodo 'fibonacci' 
RMEM 1  ; Reservamos una locacion de memoria para el resultado del metodo 'fibonacci' de la clase 'recursivos'. 
SWAP  ; Acomodamos el THIS haciendo un SWAP con RETVAL. 
.CODE
LOAD 0  ; Cargamos la variable local 'numero'. 
SWAP  ; Acomodamos el THIS cada vez que generamos el codigo para un parametro. 
PUSH VT_recursivos
LOADREF 0  ; MethodCallNode. Recuperamos la direccion del metodo 'fibonacci'. 
CALL  ; MethodCallNode. Llamamos al metodo 'fibonacci'. 
SWAP  ; Acomodamos el THIS cada vez que generamos el codigo para un parametro. 
.CODE
PUSH L_MET_System_printIln
CALL  ; Llamada al metodo 'printIln' de System. 
.CODE
RMEM 1  ; Reservamos una locacion de memoria para el this ficticio 
.CODE
.CODE
LOAD 3  ; Apilamos el THIS para invocar al metodo 'sumatoria' 
RMEM 1  ; Reservamos una locacion de memoria para el resultado del metodo 'sumatoria' de la clase 'recursivos'. 
SWAP  ; Acomodamos el THIS haciendo un SWAP con RETVAL. 
.CODE
LOAD 0  ; Cargamos la variable local 'numero'. 
SWAP  ; Acomodamos el THIS cada vez que generamos el codigo para un parametro. 
PUSH VT_recursivos
LOADREF 1  ; MethodCallNode. Recuperamos la direccion del metodo 'sumatoria'. 
CALL  ; MethodCallNode. Llamamos al metodo 'sumatoria'. 
SWAP  ; Acomodamos el THIS cada vez que generamos el codigo para un parametro. 
.CODE
PUSH L_MET_System_printIln
CALL  ; Llamada al metodo 'printIln' de System. 
.CODE
RMEM 1  ; Reservamos una locacion de memoria para el this ficticio 
.CODE
.CODE
LOAD 3  ; Apilamos el THIS para invocar al metodo 'factorial' 
RMEM 1  ; Reservamos una locacion de memoria para el resultado del metodo 'factorial' de la clase 'recursivos'. 
SWAP  ; Acomodamos el THIS haciendo un SWAP con RETVAL. 
.CODE
LOAD 0  ; Cargamos la variable local 'numero'. 
SWAP  ; Acomodamos el THIS cada vez que generamos el codigo para un parametro. 
PUSH VT_recursivos
LOADREF 2  ; MethodCallNode. Recuperamos la direccion del metodo 'factorial'. 
CALL  ; MethodCallNode. Llamamos al metodo 'factorial'. 
SWAP  ; Acomodamos el THIS cada vez que generamos el codigo para un parametro. 
.CODE
PUSH L_MET_System_printIln
CALL  ; Llamada al metodo 'printIln' de System. 
FMEM 2  ; Liberamos la memoria de las variables locales del metodo 'main' 
STOREFP ; Se actualiza el FP para que apunte al RA del llamador
RET 1  ; Retornamos de la unidad 
