.DATA
VT_Object: NOP
VT_System: DW L_MET_System_Ctor, L_MET_System_read, L_MET_System_printI, L_MET_System_printC, L_MET_System_printB, L_MET_System_printS, L_MET_System_println, L_MET_System_printBln, L_MET_System_printCln, L_MET_System_printIln, L_MET_System_printSln 
.CODE
PUSH L_SIMPLE_INIT_HEAP  ; Inicializamos el heap 
CALL
RMEM 1  ; Reservamos memoria para el this 
PUSH L_MET_Main_main  ; Apilamos el label del main de la Clase Principal del Programa 
CALL
HALT
L_MET_System_Ctor: NOP  ; Constructor de system 
LOADFP
LOADSP
STOREFP
STOREFP
RET 1
L_MET_System_read: NOP
LOADFP
LOADSP
STOREFP
READ
STORE 4
STOREFP
RET 1
L_MET_System_printI: NOP
LOADFP
LOADSP
STOREFP
LOAD 4
IPRINT
STOREFP
RET 2
L_MET_System_printC: NOP
LOADFP
LOADSP
STOREFP
LOAD 4
CPRINT
STOREFP
RET 2
L_MET_System_printB: NOP
LOADFP
LOADSP
STOREFP
LOAD 4
BPRINT
STOREFP
RET 2
L_MET_System_printS: NOP
LOADFP
LOADSP
STOREFP
LOAD 4
SPRINT
STOREFP
RET 2
L_MET_System_println: NOP
LOADFP
LOADSP
STOREFP
PRNLN
STOREFP
RET 1
L_MET_System_printBln: NOP
LOADFP
LOADSP
STOREFP
LOAD 4
BPRINT
PRNLN
STOREFP
RET 2
L_MET_System_printCln: NOP
LOADFP
LOADSP
STOREFP
LOAD 4
CPRINT
PRNLN
STOREFP
RET 2
L_MET_System_printIln: NOP
LOADFP
LOADSP
STOREFP
LOAD 4
IPRINT
PRNLN
STOREFP
RET 2
L_MET_System_printSln: NOP
LOADFP
LOADSP
STOREFP
LOAD 4
SPRINT
PRNLN
STOREFP
RET 2
L_SIMPLE_MALLOC: LOADFP  ; Inicializacion unidad 
LOADSP
STOREFP  ; Finaliza inicializacion del RA 
LOADHL  ; hl 
DUP  ; hl 
PUSH 1  ; 1 
ADD  ; hl+1 
STORE 4  ; Guarda resultado (puntero a la base del bloque) 
LOAD 3  ; Carga cantidad de celdas a alojar (parametro)  
ADD
STOREHL  ; Mueve el heap limit (hl) 
STOREFP
RET 1  ; Retorna eliminando el parametro 
L_SIMPLE_INIT_HEAP: RET 0  ; Inicializacion simplificada del .heap 
.DATA
VT_Empleado: DW L_MET_Empleado_setBase, L_MET_Empleado_getBase, L_MET_Empleado_getSueldo, L_MET_Empleado_getNombre
.CODE
; INICIALIZAMOS EL CI DEL CONSTRUCTOR 'Empleado' DE LA CLASE 'Empleado'
L_CTOR_Empleado_Empleado: LOADFP  ; Guardamos el ED al RA llamador 
LOADSP  ; Apilamos la locación donde empieza el RA de la unidad 
STOREFP  ; Actualizamos el FP con el valor del tope de la pila 
.CODE
LOAD 3  ; Apilamos el THIS para invocar al metodo 'setBase' 
.CODE
LOAD 4  ; Cargamos el parametro 'base'. 
SWAP  ; Acomodamos el THIS cada vez que generamos el codigo para un parametro. 
DUP  ; MethodCallNode. Duplicamos la referencia al CIR para utilizarla en el LOADREF al asociar la VT para invocar al metodo 'setBase'. 
LOADREF 0  ; MethodCallNode. El offset de la VT en el CIR es siempre 0. Accedemos a la VT. 
LOADREF 0  ; MethodCallNode. Recuperamos la direccion del metodo 'setBase'. 
CALL  ; MethodCallNode. Llamamos al metodo 'setBase'. 
STOREFP ; Se actualiza el FP para que apunte al RA del llamador
RET 2  ; Retornamos de la unidad 
.CODE
; INICIALIZAMOS EL CI DEL METODO 'setBase' DE LA CLASE 'Empleado'
L_MET_Empleado_setBase: LOADFP  ; Guardamos el ED al RA llamador 
LOADSP  ; Apilamos la locación donde empieza el RA de la unidad 
STOREFP  ; Actualizamos el FP con el valor del tope de la pila 
.CODE
LOAD 4  ; Cargamos el parametro 'base'. 
.CODE
LOAD 3  ; Asignacion. Apilamos THIS 
SWAP  ; Asignacion. Invertimos el orden del tope de la pila. STOREREF usa los parametros en orden inverso (CIR, valor). 
STOREREF 1  ; Asignacion. El lado izquierdo es una variable de instancia de la clase 'Empleado'. 
STOREFP ; Se actualiza el FP para que apunte al RA del llamador
RET 2  ; Retornamos de la unidad 
.CODE
; INICIALIZAMOS EL CI DEL METODO 'getBase' DE LA CLASE 'Empleado'
L_MET_Empleado_getBase: LOADFP  ; Guardamos el ED al RA llamador 
LOADSP  ; Apilamos la locación donde empieza el RA de la unidad 
STOREFP  ; Actualizamos el FP con el valor del tope de la pila 
.CODE
LOAD 3  ; Apilamos el THIS para poder acceder al CIR. 
LOADREF 1  ; Cargamos la variable de instancia 'b'. 
.CODE
; Retorno de expresion del metodo 'getBase' de la clase 'Empleado'
STORE 4  ; Almacenamos el retorno del metodo 'getBase' de la clase 'Empleado'. 
STOREFP  ; Actualizamos el FP para que apunte al RA del llamador 
RET 1  ; Retornamos de la unidad liberando el espacio que ocupaban los parametros y el THIS del metodo 'getBase' de la clase 'Empleado'. 
STOREFP ; Se actualiza el FP para que apunte al RA del llamador
RET 1  ; Retornamos de la unidad 
.CODE
; INICIALIZAMOS EL CI DEL METODO 'getSueldo' DE LA CLASE 'Empleado'
L_MET_Empleado_getSueldo: LOADFP  ; Guardamos el ED al RA llamador 
LOADSP  ; Apilamos la locación donde empieza el RA de la unidad 
STOREFP  ; Actualizamos el FP con el valor del tope de la pila 
.CODE
LOAD 3  ; Apilamos el THIS para poder acceder al CIR. 
LOADREF 1  ; Cargamos la variable de instancia 'b'. 
.CODE
; Retorno de expresion del metodo 'getSueldo' de la clase 'Empleado'
STORE 4  ; Almacenamos el retorno del metodo 'getSueldo' de la clase 'Empleado'. 
STOREFP  ; Actualizamos el FP para que apunte al RA del llamador 
RET 1  ; Retornamos de la unidad liberando el espacio que ocupaban los parametros y el THIS del metodo 'getSueldo' de la clase 'Empleado'. 
STOREFP ; Se actualiza el FP para que apunte al RA del llamador
RET 1  ; Retornamos de la unidad 
.CODE
; INICIALIZAMOS EL CI DEL METODO 'getNombre' DE LA CLASE 'Empleado'
L_MET_Empleado_getNombre: LOADFP  ; Guardamos el ED al RA llamador 
LOADSP  ; Apilamos la locación donde empieza el RA de la unidad 
STOREFP  ; Actualizamos el FP con el valor del tope de la pila 
.DATA
lString1_getNombre_Empleado: DW "Empleado", 0
.CODE
PUSH lString1_getNombre_Empleado  ; Apilamos el label del String '"Empleado"'. 
.CODE
; Retorno de expresion del metodo 'getNombre' de la clase 'Empleado'
STORE 4  ; Almacenamos el retorno del metodo 'getNombre' de la clase 'Empleado'. 
STOREFP  ; Actualizamos el FP para que apunte al RA del llamador 
RET 1  ; Retornamos de la unidad liberando el espacio que ocupaban los parametros y el THIS del metodo 'getNombre' de la clase 'Empleado'. 
STOREFP ; Se actualiza el FP para que apunte al RA del llamador
RET 1  ; Retornamos de la unidad 
.DATA
VT_EmpleadoPorComision: DW L_MET_EmpleadoPorComision_setVentas, L_MET_EmpleadoPorComision_setComision, L_MET_EmpleadoPorComision_getVentas, L_MET_EmpleadoPorComision_getComision, L_MET_EmpleadoPorComision_getSueldo, L_MET_EmpleadoPorComision_getNombre, L_MET_Empleado_setBase, L_MET_Empleado_getBase
.CODE
; INICIALIZAMOS EL CI DEL CONSTRUCTOR 'EmpleadoPorComision' DE LA CLASE 'EmpleadoPorComision'
L_CTOR_EmpleadoPorComision_EmpleadoPorComision: LOADFP  ; Guardamos el ED al RA llamador 
LOADSP  ; Apilamos la locación donde empieza el RA de la unidad 
STOREFP  ; Actualizamos el FP con el valor del tope de la pila 
.CODE
LOAD 3  ; Apilamos el THIS para invocar al metodo 'setBase' 
.CODE
PUSH 0
SWAP  ; Acomodamos el THIS cada vez que generamos el codigo para un parametro. 
DUP  ; MethodCallNode. Duplicamos la referencia al CIR para utilizarla en el LOADREF al asociar la VT para invocar al metodo 'setBase'. 
LOADREF 0  ; MethodCallNode. El offset de la VT en el CIR es siempre 0. Accedemos a la VT. 
LOADREF 0  ; MethodCallNode. Recuperamos la direccion del metodo 'setBase'. 
CALL  ; MethodCallNode. Llamamos al metodo 'setBase'. 
.CODE
LOAD 3  ; Apilamos el THIS para invocar al metodo 'setVentas' 
.CODE
PUSH 0
SWAP  ; Acomodamos el THIS cada vez que generamos el codigo para un parametro. 
DUP  ; MethodCallNode. Duplicamos la referencia al CIR para utilizarla en el LOADREF al asociar la VT para invocar al metodo 'setVentas'. 
LOADREF 0  ; MethodCallNode. El offset de la VT en el CIR es siempre 0. Accedemos a la VT. 
LOADREF 4  ; MethodCallNode. Recuperamos la direccion del metodo 'setVentas'. 
CALL  ; MethodCallNode. Llamamos al metodo 'setVentas'. 
.CODE
LOAD 3  ; Apilamos el THIS para invocar al metodo 'setComision' 
.CODE
LOAD 4  ; Cargamos el parametro 'comision'. 
SWAP  ; Acomodamos el THIS cada vez que generamos el codigo para un parametro. 
DUP  ; MethodCallNode. Duplicamos la referencia al CIR para utilizarla en el LOADREF al asociar la VT para invocar al metodo 'setComision'. 
LOADREF 0  ; MethodCallNode. El offset de la VT en el CIR es siempre 0. Accedemos a la VT. 
LOADREF 5  ; MethodCallNode. Recuperamos la direccion del metodo 'setComision'. 
CALL  ; MethodCallNode. Llamamos al metodo 'setComision'. 
STOREFP ; Se actualiza el FP para que apunte al RA del llamador
RET 2  ; Retornamos de la unidad 
.CODE
; INICIALIZAMOS EL CI DEL METODO 'setVentas' DE LA CLASE 'EmpleadoPorComision'
L_MET_EmpleadoPorComision_setVentas: LOADFP  ; Guardamos el ED al RA llamador 
LOADSP  ; Apilamos la locación donde empieza el RA de la unidad 
STOREFP  ; Actualizamos el FP con el valor del tope de la pila 
.CODE
LOAD 4  ; Cargamos el parametro 'ventas'. 
.CODE
LOAD 3  ; Asignacion. Apilamos THIS 
SWAP  ; Asignacion. Invertimos el orden del tope de la pila. STOREREF usa los parametros en orden inverso (CIR, valor). 
STOREREF 3  ; Asignacion. El lado izquierdo es una variable de instancia de la clase 'EmpleadoPorComision'. 
STOREFP ; Se actualiza el FP para que apunte al RA del llamador
RET 2  ; Retornamos de la unidad 
.CODE
; INICIALIZAMOS EL CI DEL METODO 'setComision' DE LA CLASE 'EmpleadoPorComision'
L_MET_EmpleadoPorComision_setComision: LOADFP  ; Guardamos el ED al RA llamador 
LOADSP  ; Apilamos la locación donde empieza el RA de la unidad 
STOREFP  ; Actualizamos el FP con el valor del tope de la pila 
.CODE
LOAD 4  ; Cargamos el parametro 'comision'. 
.CODE
LOAD 3  ; Asignacion. Apilamos THIS 
SWAP  ; Asignacion. Invertimos el orden del tope de la pila. STOREREF usa los parametros en orden inverso (CIR, valor). 
STOREREF 2  ; Asignacion. El lado izquierdo es una variable de instancia de la clase 'EmpleadoPorComision'. 
STOREFP ; Se actualiza el FP para que apunte al RA del llamador
RET 2  ; Retornamos de la unidad 
.CODE
; INICIALIZAMOS EL CI DEL METODO 'getVentas' DE LA CLASE 'EmpleadoPorComision'
L_MET_EmpleadoPorComision_getVentas: LOADFP  ; Guardamos el ED al RA llamador 
LOADSP  ; Apilamos la locación donde empieza el RA de la unidad 
STOREFP  ; Actualizamos el FP con el valor del tope de la pila 
.CODE
LOAD 3  ; Apilamos el THIS para poder acceder al CIR. 
LOADREF 3  ; Cargamos la variable de instancia 'v'. 
.CODE
; Retorno de expresion del metodo 'getVentas' de la clase 'EmpleadoPorComision'
STORE 4  ; Almacenamos el retorno del metodo 'getVentas' de la clase 'EmpleadoPorComision'. 
STOREFP  ; Actualizamos el FP para que apunte al RA del llamador 
RET 1  ; Retornamos de la unidad liberando el espacio que ocupaban los parametros y el THIS del metodo 'getVentas' de la clase 'EmpleadoPorComision'. 
STOREFP ; Se actualiza el FP para que apunte al RA del llamador
RET 1  ; Retornamos de la unidad 
.CODE
; INICIALIZAMOS EL CI DEL METODO 'getComision' DE LA CLASE 'EmpleadoPorComision'
L_MET_EmpleadoPorComision_getComision: LOADFP  ; Guardamos el ED al RA llamador 
LOADSP  ; Apilamos la locación donde empieza el RA de la unidad 
STOREFP  ; Actualizamos el FP con el valor del tope de la pila 
.CODE
LOAD 3  ; Apilamos el THIS para poder acceder al CIR. 
LOADREF 2  ; Cargamos la variable de instancia 'c'. 
.CODE
; Retorno de expresion del metodo 'getComision' de la clase 'EmpleadoPorComision'
STORE 4  ; Almacenamos el retorno del metodo 'getComision' de la clase 'EmpleadoPorComision'. 
STOREFP  ; Actualizamos el FP para que apunte al RA del llamador 
RET 1  ; Retornamos de la unidad liberando el espacio que ocupaban los parametros y el THIS del metodo 'getComision' de la clase 'EmpleadoPorComision'. 
STOREFP ; Se actualiza el FP para que apunte al RA del llamador
RET 1  ; Retornamos de la unidad 
.CODE
; INICIALIZAMOS EL CI DEL METODO 'getSueldo' DE LA CLASE 'EmpleadoPorComision'
L_MET_EmpleadoPorComision_getSueldo: LOADFP  ; Guardamos el ED al RA llamador 
LOADSP  ; Apilamos la locación donde empieza el RA de la unidad 
STOREFP  ; Actualizamos el FP con el valor del tope de la pila 
RMEM 3  ; Reservamos memoria para las variables locales del metodo 'getSueldo' 
.CODE
LOAD 3  ; Apilamos el THIS para invocar al metodo 'getBase' 
RMEM 1  ; Reservamos una locacion de memoria para el resultado del metodo 'getBase' de la clase 'EmpleadoPorComision'. 
SWAP  ; Acomodamos el THIS haciendo un SWAP con RETVAL. 
DUP  ; MethodCallNode. Duplicamos la referencia al CIR para utilizarla en el LOADREF al asociar la VT para invocar al metodo 'getBase'. 
LOADREF 0  ; MethodCallNode. El offset de la VT en el CIR es siempre 0. Accedemos a la VT. 
LOADREF 1  ; MethodCallNode. Recuperamos la direccion del metodo 'getBase'. 
CALL  ; MethodCallNode. Llamamos al metodo 'getBase'. 
.CODE
LOAD 3  ; Apilamos el THIS para invocar al metodo 'getVentas' 
RMEM 1  ; Reservamos una locacion de memoria para el resultado del metodo 'getVentas' de la clase 'EmpleadoPorComision'. 
SWAP  ; Acomodamos el THIS haciendo un SWAP con RETVAL. 
DUP  ; MethodCallNode. Duplicamos la referencia al CIR para utilizarla en el LOADREF al asociar la VT para invocar al metodo 'getVentas'. 
LOADREF 0  ; MethodCallNode. El offset de la VT en el CIR es siempre 0. Accedemos a la VT. 
LOADREF 6  ; MethodCallNode. Recuperamos la direccion del metodo 'getVentas'. 
CALL  ; MethodCallNode. Llamamos al metodo 'getVentas'. 
.CODE
LOAD 3  ; Apilamos el THIS para invocar al metodo 'getComision' 
RMEM 1  ; Reservamos una locacion de memoria para el resultado del metodo 'getComision' de la clase 'EmpleadoPorComision'. 
SWAP  ; Acomodamos el THIS haciendo un SWAP con RETVAL. 
DUP  ; MethodCallNode. Duplicamos la referencia al CIR para utilizarla en el LOADREF al asociar la VT para invocar al metodo 'getComision'. 
LOADREF 0  ; MethodCallNode. El offset de la VT en el CIR es siempre 0. Accedemos a la VT. 
LOADREF 7  ; MethodCallNode. Recuperamos la direccion del metodo 'getComision'. 
CALL  ; MethodCallNode. Llamamos al metodo 'getComision'. 
.CODE
MUL
.CODE
ADD
.CODE
; Retorno de expresion del metodo 'getSueldo' de la clase 'EmpleadoPorComision'
STORE 4  ; Almacenamos el retorno del metodo 'getSueldo' de la clase 'EmpleadoPorComision'. 
FMEM 3  ; Liberamos el espacio usado por las variables locales del metodo 'getSueldo' de la clase 'EmpleadoPorComision'. 
STOREFP  ; Actualizamos el FP para que apunte al RA del llamador 
RET 1  ; Retornamos de la unidad liberando el espacio que ocupaban los parametros y el THIS del metodo 'getSueldo' de la clase 'EmpleadoPorComision'. 
FMEM 3  ; Liberamos la memoria de las variables locales del metodo 'getSueldo' 
STOREFP ; Se actualiza el FP para que apunte al RA del llamador
RET 1  ; Retornamos de la unidad 
.CODE
; INICIALIZAMOS EL CI DEL METODO 'getNombre' DE LA CLASE 'EmpleadoPorComision'
L_MET_EmpleadoPorComision_getNombre: LOADFP  ; Guardamos el ED al RA llamador 
LOADSP  ; Apilamos la locación donde empieza el RA de la unidad 
STOREFP  ; Actualizamos el FP con el valor del tope de la pila 
.DATA
lString2_getNombre_EmpleadoPorComision: DW "EmpleadoPorComision", 0
.CODE
PUSH lString2_getNombre_EmpleadoPorComision  ; Apilamos el label del String '"EmpleadoPorComision"'. 
.CODE
; Retorno de expresion del metodo 'getNombre' de la clase 'EmpleadoPorComision'
STORE 4  ; Almacenamos el retorno del metodo 'getNombre' de la clase 'EmpleadoPorComision'. 
STOREFP  ; Actualizamos el FP para que apunte al RA del llamador 
RET 1  ; Retornamos de la unidad liberando el espacio que ocupaban los parametros y el THIS del metodo 'getNombre' de la clase 'EmpleadoPorComision'. 
STOREFP ; Se actualiza el FP para que apunte al RA del llamador
RET 1  ; Retornamos de la unidad 
.DATA
VT_EmpleadoPorComisionConBase: DW L_MET_EmpleadoPorComisionConBase_getNombre, L_MET_EmpleadoPorComision_setVentas, L_MET_EmpleadoPorComision_setComision, L_MET_EmpleadoPorComision_getVentas, L_MET_EmpleadoPorComision_getComision, L_MET_EmpleadoPorComision_getSueldo, L_MET_Empleado_setBase, L_MET_Empleado_getBase
.CODE
; INICIALIZAMOS EL CI DEL CONSTRUCTOR 'EmpleadoPorComisionConBase' DE LA CLASE 'EmpleadoPorComisionConBase'
L_CTOR_EmpleadoPorComisionConBase_EmpleadoPorComisionConBase: LOADFP  ; Guardamos el ED al RA llamador 
LOADSP  ; Apilamos la locación donde empieza el RA de la unidad 
STOREFP  ; Actualizamos el FP con el valor del tope de la pila 
.CODE
LOAD 3  ; Apilamos el THIS para invocar al metodo 'setBase' 
.CODE
LOAD 5  ; Cargamos el parametro 'base'. 
SWAP  ; Acomodamos el THIS cada vez que generamos el codigo para un parametro. 
DUP  ; MethodCallNode. Duplicamos la referencia al CIR para utilizarla en el LOADREF al asociar la VT para invocar al metodo 'setBase'. 
LOADREF 0  ; MethodCallNode. El offset de la VT en el CIR es siempre 0. Accedemos a la VT. 
LOADREF 0  ; MethodCallNode. Recuperamos la direccion del metodo 'setBase'. 
CALL  ; MethodCallNode. Llamamos al metodo 'setBase'. 
.CODE
LOAD 3  ; Apilamos el THIS para invocar al metodo 'setVentas' 
.CODE
PUSH 0
SWAP  ; Acomodamos el THIS cada vez que generamos el codigo para un parametro. 
DUP  ; MethodCallNode. Duplicamos la referencia al CIR para utilizarla en el LOADREF al asociar la VT para invocar al metodo 'setVentas'. 
LOADREF 0  ; MethodCallNode. El offset de la VT en el CIR es siempre 0. Accedemos a la VT. 
LOADREF 4  ; MethodCallNode. Recuperamos la direccion del metodo 'setVentas'. 
CALL  ; MethodCallNode. Llamamos al metodo 'setVentas'. 
.CODE
LOAD 3  ; Apilamos el THIS para invocar al metodo 'setComision' 
.CODE
LOAD 4  ; Cargamos el parametro 'comision'. 
SWAP  ; Acomodamos el THIS cada vez que generamos el codigo para un parametro. 
DUP  ; MethodCallNode. Duplicamos la referencia al CIR para utilizarla en el LOADREF al asociar la VT para invocar al metodo 'setComision'. 
LOADREF 0  ; MethodCallNode. El offset de la VT en el CIR es siempre 0. Accedemos a la VT. 
LOADREF 5  ; MethodCallNode. Recuperamos la direccion del metodo 'setComision'. 
CALL  ; MethodCallNode. Llamamos al metodo 'setComision'. 
STOREFP ; Se actualiza el FP para que apunte al RA del llamador
RET 3  ; Retornamos de la unidad 
.CODE
; INICIALIZAMOS EL CI DEL METODO 'getNombre' DE LA CLASE 'EmpleadoPorComisionConBase'
L_MET_EmpleadoPorComisionConBase_getNombre: LOADFP  ; Guardamos el ED al RA llamador 
LOADSP  ; Apilamos la locación donde empieza el RA de la unidad 
STOREFP  ; Actualizamos el FP con el valor del tope de la pila 
.DATA
lString3_getNombre_EmpleadoPorComisionConBase: DW "EmpleadoPorComisionConBase", 0
.CODE
PUSH lString3_getNombre_EmpleadoPorComisionConBase  ; Apilamos el label del String '"EmpleadoPorComisionConBase"'. 
.CODE
; Retorno de expresion del metodo 'getNombre' de la clase 'EmpleadoPorComisionConBase'
STORE 4  ; Almacenamos el retorno del metodo 'getNombre' de la clase 'EmpleadoPorComisionConBase'. 
STOREFP  ; Actualizamos el FP para que apunte al RA del llamador 
RET 1  ; Retornamos de la unidad liberando el espacio que ocupaban los parametros y el THIS del metodo 'getNombre' de la clase 'EmpleadoPorComisionConBase'. 
STOREFP ; Se actualiza el FP para que apunte al RA del llamador
RET 1  ; Retornamos de la unidad 
.DATA
VT_Main: DW L_MET_Main_main
.CODE
; INICIALIZAMOS EL CI DEL CONSTRUCTOR 'Main' DE LA CLASE 'Main'
L_CTOR_Main_Main: LOADFP  ; Guardamos el ED al RA llamador 
LOADSP  ; Apilamos la locación donde empieza el RA de la unidad 
STOREFP  ; Actualizamos el FP con el valor del tope de la pila 
STOREFP ; Se actualiza el FP para que apunte al RA del llamador
RET 1  ; Retornamos de la unidad 
.CODE
; INICIALIZAMOS EL CI DEL METODO 'main' DE LA CLASE 'Main'
L_MET_Main_main: LOADFP  ; Guardamos el ED al RA llamador 
LOADSP  ; Apilamos la locación donde empieza el RA de la unidad 
STOREFP  ; Actualizamos el FP con el valor del tope de la pila 
RMEM 3  ; Reservamos memoria para las variables locales del metodo 'main' 
.CODE
RMEM 1  ; Llamada al constructor de la clase 'Empleado'. Se reserva memoria para la referencia al nuevo CIR 
PUSH 2  ; Apilamos la cantidad de variables de instancia del nuevo CIR mas el espacio para la VT. 
PUSH L_SIMPLE_MALLOC  ; Apilamos la direccion de la rutina para reservar memoria en el heap 
CALL  ; Invocamos a la rutina en el tope de la pila (lsimple_malloc) 
DUP  ; Duplicamos la referencia al nuevo CIR para el STOREREF. 
PUSH VT_Empleado  ; Apilamos la direccion del comienzo de la VT del id en la creacion de un CIR 
STOREREF 0  ; Guardamos las referencia a la VT en el CIR creado. El offset 0 en el CIR se corresponde a la VT 
DUP  ; Duplicamos el THIS para el RA del constructor quedando, al finalizar la ejecucion, en el tope de la pila 
.CODE
PUSH 1000
.CODE
SWAP  ; Acomodamos el THIS cada vez que generamos el codigo para un parametro. 
.CODE
PUSH L_CTOR_Empleado_Empleado  ; Apilamos la direccion del constructor de la clase 'Empleado'. 
CALL  ; Invocamos la rutina del constructor de la clase 'Empleado' 
.CODE
STORE 0  ; Asignacion. El lado izquierdo es una variable local del metodo 'main' 
.CODE
RMEM 1  ; Reservamos una locacion de memoria para el this ficticio 
.CODE
.CODE
LOAD 0  ; Cargamos la variable local 'e'. 
.CODE
RMEM 1  ; Reservamos una locacion de memoria para el resultado del metodo 'getNombre' de la clase 'Main' 
SWAP  ; Acomodamos el THIS haciendo un SWAP con RETVAL 
.CODE
DUP  ; CallNode. Duplicamos la referencia al CIR para utilizarla en el LOADREF al asociar la VT para invocar al metodo 'getNombre'. 
LOADREF 0  ; CallNode. El offset de la VT en el CIR es siempre 0. Accedemos a la VT. 
LOADREF 3  ; CallNode. Recuperamos la direccion del metodo 'getNombre'. 
CALL  ; CallNode. Llamamos al metodo 'getNombre'. 
SWAP  ; Acomodamos el THIS cada vez que generamos el codigo para un parametro. 
.CODE
PUSH L_MET_System_printS
CALL  ; Llamada al metodo 'printS' de System. 
.CODE
RMEM 1  ; Reservamos una locacion de memoria para el this ficticio 
.CODE
PUSH 32  ; Apilo el caracter ' ' 
SWAP  ; Acomodamos el THIS cada vez que generamos el codigo para un parametro. 
.CODE
PUSH L_MET_System_printC
CALL  ; Llamada al metodo 'printC' de System. 
.CODE
RMEM 1  ; Reservamos una locacion de memoria para el this ficticio 
.CODE
PUSH 32  ; Apilo el caracter ' ' 
SWAP  ; Acomodamos el THIS cada vez que generamos el codigo para un parametro. 
.CODE
PUSH L_MET_System_printC
CALL  ; Llamada al metodo 'printC' de System. 
.CODE
RMEM 1  ; Reservamos una locacion de memoria para el this ficticio 
.CODE
PUSH 32  ; Apilo el caracter ' ' 
SWAP  ; Acomodamos el THIS cada vez que generamos el codigo para un parametro. 
.CODE
PUSH L_MET_System_printC
CALL  ; Llamada al metodo 'printC' de System. 
.CODE
RMEM 1  ; Reservamos una locacion de memoria para el this ficticio 
.CODE
.CODE
LOAD 0  ; Cargamos la variable local 'e'. 
.CODE
RMEM 1  ; Reservamos una locacion de memoria para el resultado del metodo 'getSueldo' de la clase 'Main' 
SWAP  ; Acomodamos el THIS haciendo un SWAP con RETVAL 
.CODE
DUP  ; CallNode. Duplicamos la referencia al CIR para utilizarla en el LOADREF al asociar la VT para invocar al metodo 'getSueldo'. 
LOADREF 0  ; CallNode. El offset de la VT en el CIR es siempre 0. Accedemos a la VT. 
LOADREF 2  ; CallNode. Recuperamos la direccion del metodo 'getSueldo'. 
CALL  ; CallNode. Llamamos al metodo 'getSueldo'. 
SWAP  ; Acomodamos el THIS cada vez que generamos el codigo para un parametro. 
.CODE
PUSH L_MET_System_printIln
CALL  ; Llamada al metodo 'printIln' de System. 
.CODE
RMEM 1  ; Llamada al constructor de la clase 'EmpleadoPorComision'. Se reserva memoria para la referencia al nuevo CIR 
PUSH 4  ; Apilamos la cantidad de variables de instancia del nuevo CIR mas el espacio para la VT. 
PUSH L_SIMPLE_MALLOC  ; Apilamos la direccion de la rutina para reservar memoria en el heap 
CALL  ; Invocamos a la rutina en el tope de la pila (lsimple_malloc) 
DUP  ; Duplicamos la referencia al nuevo CIR para el STOREREF. 
PUSH VT_EmpleadoPorComision  ; Apilamos la direccion del comienzo de la VT del id en la creacion de un CIR 
STOREREF 0  ; Guardamos las referencia a la VT en el CIR creado. El offset 0 en el CIR se corresponde a la VT 
DUP  ; Duplicamos el THIS para el RA del constructor quedando, al finalizar la ejecucion, en el tope de la pila 
.CODE
PUSH 250
.CODE
SWAP  ; Acomodamos el THIS cada vez que generamos el codigo para un parametro. 
.CODE
PUSH L_CTOR_EmpleadoPorComision_EmpleadoPorComision  ; Apilamos la direccion del constructor de la clase 'EmpleadoPorComision'. 
CALL  ; Invocamos la rutina del constructor de la clase 'EmpleadoPorComision' 
.CODE
STORE -2  ; Asignacion. El lado izquierdo es una variable local del metodo 'main' 
FMEM 3  ; Liberamos la memoria de las variables locales del metodo 'main' 
STOREFP ; Se actualiza el FP para que apunte al RA del llamador
RET 1  ; Retornamos de la unidad 
