.DATA
VT_Object_0: NOP
VT_System_1: DW L_MET_System_1_Ctor, L_MET_System_1_read, L_MET_System_1_printI, L_MET_System_1_printC, L_MET_System_1_printB, L_MET_System_1_printS, L_MET_System_1_println, L_MET_System_1_printBln, L_MET_System_1_printCln, L_MET_System_1_printIln, L_MET_System_1_printSln 
.CODE
PUSH L_SIMPLE_INIT_HEAP
CALL
RMEM 1
PUSH L_MET_A3_4_main_9
CALL
HALT
L_MET_System_1_Ctor: NOP  ; Constructor de system 
LOADFP
LOADSP
STOREFP
STOREFP
RET 1
L_MET_System_1_read: NOP
LOADFP
LOADSP
STOREFP
READ
STORE 4
STOREFP
RET 1
L_MET_System_1_printI: NOP
LOADFP
LOADSP
STOREFP
LOAD 4
IPRINT
STOREFP
RET 2
L_MET_System_1_printC: NOP
LOADFP
LOADSP
STOREFP
LOAD 4
CPRINT
STOREFP
RET 2
L_MET_System_1_printB: NOP
LOADFP
LOADSP
STOREFP
LOAD 4
BPRINT
STOREFP
RET 2
L_MET_System_1_printS: NOP
LOADFP
LOADSP
STOREFP
LOAD 4
SPRINT
STOREFP
RET 2
L_MET_System_1_println: NOP
LOADFP
LOADSP
STOREFP
PRNLN
STOREFP
RET 1
L_MET_System_1_printBln: NOP
LOADFP
LOADSP
STOREFP
LOAD 4
BPRINT
PRNLN
STOREFP
RET 2
L_MET_System_1_printCln: NOP
LOADFP
LOADSP
STOREFP
LOAD 4
CPRINT
PRNLN
STOREFP
RET 2
L_MET_System_1_printIln: NOP
LOADFP
LOADSP
STOREFP
LOAD 4
IPRINT
PRNLN
STOREFP
RET 2
L_MET_System_1_printSln: NOP
LOADFP
LOADSP
STOREFP
LOAD 4
SPRINT
PRNLN
STOREFP
RET 2
L_SIMPLE_MALLOC: NOP
LOADFP
LOADSP
STOREFP
LOADHL
DUP
PUSH 1
ADD
STORE 4
LOAD 3
ADD
STOREHL
STOREFP
RET 1
L_SIMPLE_INIT_HEAP: RET 0  ; Inicializacion simplificada del .heap 
.DATA
VT_A_2: DW L_MET_A_2_printA_0, L_MET_A_2_geti1_1, L_MET_A_2_seti1_2
.CODE
; INICIALIZAMOS EL CI DEL CONSTRUCTOR 'A' DE LA CLASE 'A'
L_CTOR_A_2_A: LOADFP  ; Guardamos el ED al RA llamador 
LOADSP  ; Apilamos la locación donde empieza el RA de la unidad 
STOREFP  ; Actualizamos el FP con el valor del tope de la pila 
.CODE
LOAD 4  ; IdMethodCallNode. Cargamos el parametro 'i2'. 
.CODE
LOAD 3  ; AssignNode. Apilamos THIS 
SWAP  ; AssignNode. Invertimos el orden del tope de la pila. STOREREF usa los parametros en orden inverso (CIR, valor). 
STOREREF 1  ; AssignNode. El lado izquierdo es una variable de instancia de la clase 'A'. 
.CODE
RMEM 1  ; IdMethodCallNode. Reservamos una locacion de memoria para el this ficticio. 
.CODE
.DATA
lString1_A_A: DW "A :: A() :: i1 ", 0
.CODE
PUSH lString1_A_A  ; Apilamos el label del String '"A :: A() :: i1 "'. 
SWAP  ; CallNode. Acomodamos el THIS cada vez que generamos el codigo para un parametro. 
.CODE
PUSH L_MET_System_1_printSln
CALL  ; CallNode. Llamada al metodo 'printSln' de System. 
.CODE
RMEM 1  ; IdMethodCallNode. Reservamos una locacion de memoria para el this ficticio. 
.CODE
.CODE
LOAD 3  ; IdMethodCallNode. Apilamos el THIS para poder acceder al CIR. 
LOADREF 1  ; IdMethodCallNode. Cargamos la variable de instancia 'i1'. 
SWAP  ; CallNode. Acomodamos el THIS cada vez que generamos el codigo para un parametro. 
.CODE
PUSH L_MET_System_1_printIln
CALL  ; CallNode. Llamada al metodo 'printIln' de System. 
STOREFP ; Se actualiza el FP para que apunte al RA del llamador
RET 2  ; Retornamos de la unidad 
.CODE
; INICIALIZAMOS EL CI DEL METODO 'printA' DE LA CLASE 'A'
L_MET_A_2_printA_0: LOADFP  ; Guardamos el ED al RA llamador 
LOADSP  ; Apilamos la locación donde empieza el RA de la unidad 
STOREFP  ; Actualizamos el FP con el valor del tope de la pila 
RMEM 1  ; Reservamos memoria para las variables locales del metodo 'printA' 
.CODE
RMEM 1  ; IdMethodCallNode. Reservamos una locacion de memoria para el this ficticio. 
.CODE
.DATA
lString2_printA_A: DW "A :: printA() :: i1 ", 0
.CODE
PUSH lString2_printA_A  ; Apilamos el label del String '"A :: printA() :: i1 "'. 
SWAP  ; CallNode. Acomodamos el THIS cada vez que generamos el codigo para un parametro. 
.CODE
PUSH L_MET_System_1_printS
CALL  ; CallNode. Llamada al metodo 'printS' de System. 
.CODE
LOAD 3  ; MethodCallNode. Apilamos el THIS para invocar al metodo 'geti1'. 
RMEM 1  ; MethodCallNode. Reservamos una locacion de memoria para el resultado del metodo 'geti1' de la clase 'A'. 
SWAP  ; MethodCallNode. Acomodamos el THIS haciendo un SWAP con RETVAL. 
DUP  ; MethodCallNode. Duplicamos la referencia al CIR para utilizarla en el LOADREF al asociar la VT para invocar al metodo 'geti1'. 
LOADREF 0  ; MethodCallNode. El offset de la VT en el CIR es siempre 0. Accedemos a la VT. 
LOADREF 1  ; MethodCallNode. Recuperamos la direccion del metodo 'geti1'. 
CALL  ; MethodCallNode. Llamamos al metodo 'geti1'. 
.CODE
STORE 0  ; AssignNode. El lado izquierdo es una variable local del metodo 'printA'. 
.CODE
RMEM 1  ; IdMethodCallNode. Reservamos una locacion de memoria para el this ficticio. 
.CODE
.CODE
LOAD 0  ; IdMethodCallNode. Cargamos la variable local 'i2'. 
SWAP  ; CallNode. Acomodamos el THIS cada vez que generamos el codigo para un parametro. 
.CODE
PUSH L_MET_System_1_printIln
CALL  ; CallNode. Llamada al metodo 'printIln' de System. 
FMEM 1  ; Liberamos la memoria de las variables locales del metodo 'printA' 
STOREFP ; Se actualiza el FP para que apunte al RA del llamador
RET 1  ; Retornamos de la unidad 
.CODE
; INICIALIZAMOS EL CI DEL METODO 'geti1' DE LA CLASE 'A'
L_MET_A_2_geti1_1: LOADFP  ; Guardamos el ED al RA llamador 
LOADSP  ; Apilamos la locación donde empieza el RA de la unidad 
STOREFP  ; Actualizamos el FP con el valor del tope de la pila 
.CODE
RMEM 1  ; IdMethodCallNode. Reservamos una locacion de memoria para el this ficticio. 
.CODE
.DATA
lString3_geti1_A: DW "A :: geti1() ", 0
.CODE
PUSH lString3_geti1_A  ; Apilamos el label del String '"A :: geti1() "'. 
SWAP  ; CallNode. Acomodamos el THIS cada vez que generamos el codigo para un parametro. 
.CODE
PUSH L_MET_System_1_printSln
CALL  ; CallNode. Llamada al metodo 'printSln' de System. 
.CODE
LOAD 3  ; IdMethodCallNode. Apilamos el THIS para poder acceder al CIR. 
LOADREF 1  ; IdMethodCallNode. Cargamos la variable de instancia 'i1'. 
.CODE
; Retorno de expresion del metodo 'geti1' de la clase 'A'.
STORE 4  ; ReturnExpNode. Almacenamos el retorno del metodo 'geti1' de la clase 'A'. 
STOREFP  ; ReturnExpNode. Actualizamos el FP para que apunte al RA del llamador 
RET 1  ; ReturnExpNode. Retornamos de la unidad liberando el espacio que ocupaban los parametros y el THIS del metodo 'geti1' de la clase 'A'. 
STOREFP ; Se actualiza el FP para que apunte al RA del llamador
RET 1  ; Retornamos de la unidad 
.CODE
; INICIALIZAMOS EL CI DEL METODO 'seti1' DE LA CLASE 'A'
L_MET_A_2_seti1_2: LOADFP  ; Guardamos el ED al RA llamador 
LOADSP  ; Apilamos la locación donde empieza el RA de la unidad 
STOREFP  ; Actualizamos el FP con el valor del tope de la pila 
.CODE
RMEM 1  ; IdMethodCallNode. Reservamos una locacion de memoria para el this ficticio. 
.CODE
.DATA
lString4_seti1_A: DW "A :: seti1() ", 0
.CODE
PUSH lString4_seti1_A  ; Apilamos el label del String '"A :: seti1() "'. 
SWAP  ; CallNode. Acomodamos el THIS cada vez que generamos el codigo para un parametro. 
.CODE
PUSH L_MET_System_1_printSln
CALL  ; CallNode. Llamada al metodo 'printSln' de System. 
.CODE
LOAD 4  ; IdMethodCallNode. Cargamos el parametro 'i2'. 
.CODE
LOAD 3  ; AssignNode. Apilamos THIS 
SWAP  ; AssignNode. Invertimos el orden del tope de la pila. STOREREF usa los parametros en orden inverso (CIR, valor). 
STOREREF 1  ; AssignNode. El lado izquierdo es una variable de instancia de la clase 'A'. 
STOREFP ; Se actualiza el FP para que apunte al RA del llamador
RET 2  ; Retornamos de la unidad 
.DATA
VT_A2_3: DW L_MET_A_2_printA_0, L_MET_A2_3_geti1_1, L_MET_A2_3_seti1_2, L_MET_A2_3_geti3_3, L_MET_A2_3_seti3_4, L_MET_A2_3_print_5
.CODE
; INICIALIZAMOS EL CI DEL CONSTRUCTOR 'A2' DE LA CLASE 'A2'
L_CTOR_A2_3_A2: LOADFP  ; Guardamos el ED al RA llamador 
LOADSP  ; Apilamos la locación donde empieza el RA de la unidad 
STOREFP  ; Actualizamos el FP con el valor del tope de la pila 
.CODE
LOAD 5  ; IdMethodCallNode. Cargamos el parametro 'i2'. 
.CODE
LOAD 3  ; AssignNode. Apilamos THIS 
SWAP  ; AssignNode. Invertimos el orden del tope de la pila. STOREREF usa los parametros en orden inverso (CIR, valor). 
STOREREF 3  ; AssignNode. El lado izquierdo es una variable de instancia de la clase 'A2'. 
.CODE
LOAD 4  ; IdMethodCallNode. Cargamos el parametro 'i4'. 
.CODE
LOAD 3  ; AssignNode. Apilamos THIS 
SWAP  ; AssignNode. Invertimos el orden del tope de la pila. STOREREF usa los parametros en orden inverso (CIR, valor). 
STOREREF 2  ; AssignNode. El lado izquierdo es una variable de instancia de la clase 'A2'. 
.CODE
RMEM 1  ; IdMethodCallNode. Reservamos una locacion de memoria para el this ficticio. 
.CODE
.DATA
lString5_A2_A2: DW "A2 :: A2() :: i1 ", 0
.CODE
PUSH lString5_A2_A2  ; Apilamos el label del String '"A2 :: A2() :: i1 "'. 
SWAP  ; CallNode. Acomodamos el THIS cada vez que generamos el codigo para un parametro. 
.CODE
PUSH L_MET_System_1_printSln
CALL  ; CallNode. Llamada al metodo 'printSln' de System. 
.CODE
RMEM 1  ; IdMethodCallNode. Reservamos una locacion de memoria para el this ficticio. 
.CODE
.CODE
LOAD 3  ; IdMethodCallNode. Apilamos el THIS para poder acceder al CIR. 
LOADREF 3  ; IdMethodCallNode. Cargamos la variable de instancia 'i1'. 
SWAP  ; CallNode. Acomodamos el THIS cada vez que generamos el codigo para un parametro. 
.CODE
PUSH L_MET_System_1_printI
CALL  ; CallNode. Llamada al metodo 'printI' de System. 
.CODE
RMEM 1  ; IdMethodCallNode. Reservamos una locacion de memoria para el this ficticio. 
.CODE
.DATA
lString6_A2_A2: DW "A2 :: A2() :: i2 ", 0
.CODE
PUSH lString6_A2_A2  ; Apilamos el label del String '"A2 :: A2() :: i2 "'. 
SWAP  ; CallNode. Acomodamos el THIS cada vez que generamos el codigo para un parametro. 
.CODE
PUSH L_MET_System_1_printSln
CALL  ; CallNode. Llamada al metodo 'printSln' de System. 
.CODE
RMEM 1  ; IdMethodCallNode. Reservamos una locacion de memoria para el this ficticio. 
.CODE
.CODE
LOAD 3  ; IdMethodCallNode. Apilamos el THIS para poder acceder al CIR. 
LOADREF 2  ; IdMethodCallNode. Cargamos la variable de instancia 'i3'. 
SWAP  ; CallNode. Acomodamos el THIS cada vez que generamos el codigo para un parametro. 
.CODE
PUSH L_MET_System_1_printIln
CALL  ; CallNode. Llamada al metodo 'printIln' de System. 
STOREFP ; Se actualiza el FP para que apunte al RA del llamador
RET 3  ; Retornamos de la unidad 
.CODE
; INICIALIZAMOS EL CI DEL METODO 'geti1' DE LA CLASE 'A2'
L_MET_A2_3_geti1_1: LOADFP  ; Guardamos el ED al RA llamador 
LOADSP  ; Apilamos la locación donde empieza el RA de la unidad 
STOREFP  ; Actualizamos el FP con el valor del tope de la pila 
RMEM 1  ; Reservamos memoria para las variables locales del metodo 'geti1' 
.CODE
RMEM 1  ; IdMethodCallNode. Reservamos una locacion de memoria para el this ficticio. 
.CODE
.DATA
lString7_geti1_A2: DW "A2 :: geti1() ", 0
.CODE
PUSH lString7_geti1_A2  ; Apilamos el label del String '"A2 :: geti1() "'. 
SWAP  ; CallNode. Acomodamos el THIS cada vez que generamos el codigo para un parametro. 
.CODE
PUSH L_MET_System_1_printSln
CALL  ; CallNode. Llamada al metodo 'printSln' de System. 
.CODE
LOAD 3  ; IdMethodCallNode. Apilamos el THIS para poder acceder al CIR. 
LOADREF 3  ; IdMethodCallNode. Cargamos la variable de instancia 'i1'. 
.CODE
STORE 0  ; AssignNode. El lado izquierdo es una variable local del metodo 'geti1'. 
.CODE
LOAD 0  ; IdMethodCallNode. Cargamos la variable local 'ret'. 
.CODE
; Retorno de expresion del metodo 'geti1' de la clase 'A2'.
STORE 4  ; ReturnExpNode. Almacenamos el retorno del metodo 'geti1' de la clase 'A2'. 
FMEM 1  ; ReturnExpNode. Liberamos el espacio usado por las variables locales del metodo 'geti1' de la clase 'A2'. 
STOREFP  ; ReturnExpNode. Actualizamos el FP para que apunte al RA del llamador 
RET 1  ; ReturnExpNode. Retornamos de la unidad liberando el espacio que ocupaban los parametros y el THIS del metodo 'geti1' de la clase 'A2'. 
FMEM 1  ; Liberamos la memoria de las variables locales del metodo 'geti1' 
STOREFP ; Se actualiza el FP para que apunte al RA del llamador
RET 1  ; Retornamos de la unidad 
.CODE
; INICIALIZAMOS EL CI DEL METODO 'geti3' DE LA CLASE 'A2'
L_MET_A2_3_geti3_3: LOADFP  ; Guardamos el ED al RA llamador 
LOADSP  ; Apilamos la locación donde empieza el RA de la unidad 
STOREFP  ; Actualizamos el FP con el valor del tope de la pila 
RMEM 1  ; Reservamos memoria para las variables locales del metodo 'geti3' 
.CODE
RMEM 1  ; IdMethodCallNode. Reservamos una locacion de memoria para el this ficticio. 
.CODE
.DATA
lString8_geti3_A2: DW "A2 :: geti3() ", 0
.CODE
PUSH lString8_geti3_A2  ; Apilamos el label del String '"A2 :: geti3() "'. 
SWAP  ; CallNode. Acomodamos el THIS cada vez que generamos el codigo para un parametro. 
.CODE
PUSH L_MET_System_1_printSln
CALL  ; CallNode. Llamada al metodo 'printSln' de System. 
.CODE
LOAD 3  ; IdMethodCallNode. Apilamos el THIS para poder acceder al CIR. 
LOADREF 2  ; IdMethodCallNode. Cargamos la variable de instancia 'i3'. 
.CODE
STORE 0  ; AssignNode. El lado izquierdo es una variable local del metodo 'geti3'. 
.CODE
LOAD 0  ; IdMethodCallNode. Cargamos la variable local 'ret'. 
.CODE
; Retorno de expresion del metodo 'geti3' de la clase 'A2'.
STORE 4  ; ReturnExpNode. Almacenamos el retorno del metodo 'geti3' de la clase 'A2'. 
FMEM 1  ; ReturnExpNode. Liberamos el espacio usado por las variables locales del metodo 'geti3' de la clase 'A2'. 
STOREFP  ; ReturnExpNode. Actualizamos el FP para que apunte al RA del llamador 
RET 1  ; ReturnExpNode. Retornamos de la unidad liberando el espacio que ocupaban los parametros y el THIS del metodo 'geti3' de la clase 'A2'. 
FMEM 1  ; Liberamos la memoria de las variables locales del metodo 'geti3' 
STOREFP ; Se actualiza el FP para que apunte al RA del llamador
RET 1  ; Retornamos de la unidad 
.CODE
; INICIALIZAMOS EL CI DEL METODO 'seti1' DE LA CLASE 'A2'
L_MET_A2_3_seti1_2: LOADFP  ; Guardamos el ED al RA llamador 
LOADSP  ; Apilamos la locación donde empieza el RA de la unidad 
STOREFP  ; Actualizamos el FP con el valor del tope de la pila 
.CODE
RMEM 1  ; IdMethodCallNode. Reservamos una locacion de memoria para el this ficticio. 
.CODE
.DATA
lString9_seti1_A2: DW "A2 :: seti1() ", 0
.CODE
PUSH lString9_seti1_A2  ; Apilamos el label del String '"A2 :: seti1() "'. 
SWAP  ; CallNode. Acomodamos el THIS cada vez que generamos el codigo para un parametro. 
.CODE
PUSH L_MET_System_1_printSln
CALL  ; CallNode. Llamada al metodo 'printSln' de System. 
.CODE
RMEM 1  ; IdMethodCallNode. Reservamos una locacion de memoria para el this ficticio. 
.CODE
.DATA
lString10_seti1_A2: DW "Valor anterior de i1: ", 0
.CODE
PUSH lString10_seti1_A2  ; Apilamos el label del String '"Valor anterior de i1: "'. 
SWAP  ; CallNode. Acomodamos el THIS cada vez que generamos el codigo para un parametro. 
.CODE
PUSH L_MET_System_1_printS
CALL  ; CallNode. Llamada al metodo 'printS' de System. 
.CODE
RMEM 1  ; IdMethodCallNode. Reservamos una locacion de memoria para el this ficticio. 
.CODE
.CODE
LOAD 3  ; IdMethodCallNode. Apilamos el THIS para poder acceder al CIR. 
LOADREF 3  ; IdMethodCallNode. Cargamos la variable de instancia 'i1'. 
SWAP  ; CallNode. Acomodamos el THIS cada vez que generamos el codigo para un parametro. 
.CODE
PUSH L_MET_System_1_printIln
CALL  ; CallNode. Llamada al metodo 'printIln' de System. 
.CODE
RMEM 1  ; IdMethodCallNode. Reservamos una locacion de memoria para el this ficticio. 
.CODE
.DATA
lString11_seti1_A2: DW "Valor actual de i1: ", 0
.CODE
PUSH lString11_seti1_A2  ; Apilamos el label del String '"Valor actual de i1: "'. 
SWAP  ; CallNode. Acomodamos el THIS cada vez que generamos el codigo para un parametro. 
.CODE
PUSH L_MET_System_1_printS
CALL  ; CallNode. Llamada al metodo 'printS' de System. 
.CODE
RMEM 1  ; IdMethodCallNode. Reservamos una locacion de memoria para el this ficticio. 
.CODE
.CODE
LOAD 4  ; IdMethodCallNode. Cargamos el parametro 'i2'. 
SWAP  ; CallNode. Acomodamos el THIS cada vez que generamos el codigo para un parametro. 
.CODE
PUSH L_MET_System_1_printIln
CALL  ; CallNode. Llamada al metodo 'printIln' de System. 
.CODE
LOAD 4  ; IdMethodCallNode. Cargamos el parametro 'i2'. 
.CODE
LOAD 3  ; AssignNode. Apilamos THIS 
SWAP  ; AssignNode. Invertimos el orden del tope de la pila. STOREREF usa los parametros en orden inverso (CIR, valor). 
STOREREF 3  ; AssignNode. El lado izquierdo es una variable de instancia de la clase 'A2'. 
.CODE
RMEM 1  ; IdMethodCallNode. Reservamos una locacion de memoria para el this ficticio. 
.CODE
.DATA
lString12_seti1_A2: DW "Resultado de la asignacion: ", 0
.CODE
PUSH lString12_seti1_A2  ; Apilamos el label del String '"Resultado de la asignacion: "'. 
SWAP  ; CallNode. Acomodamos el THIS cada vez que generamos el codigo para un parametro. 
.CODE
PUSH L_MET_System_1_printS
CALL  ; CallNode. Llamada al metodo 'printS' de System. 
.CODE
RMEM 1  ; IdMethodCallNode. Reservamos una locacion de memoria para el this ficticio. 
.CODE
.CODE
LOAD 3  ; IdMethodCallNode. Apilamos el THIS para poder acceder al CIR. 
LOADREF 3  ; IdMethodCallNode. Cargamos la variable de instancia 'i1'. 
SWAP  ; CallNode. Acomodamos el THIS cada vez que generamos el codigo para un parametro. 
.CODE
PUSH L_MET_System_1_printIln
CALL  ; CallNode. Llamada al metodo 'printIln' de System. 
STOREFP ; Se actualiza el FP para que apunte al RA del llamador
RET 2  ; Retornamos de la unidad 
.CODE
; INICIALIZAMOS EL CI DEL METODO 'seti3' DE LA CLASE 'A2'
L_MET_A2_3_seti3_4: LOADFP  ; Guardamos el ED al RA llamador 
LOADSP  ; Apilamos la locación donde empieza el RA de la unidad 
STOREFP  ; Actualizamos el FP con el valor del tope de la pila 
.CODE
RMEM 1  ; IdMethodCallNode. Reservamos una locacion de memoria para el this ficticio. 
.CODE
.DATA
lString13_seti3_A2: DW "A2 :: seti3() ", 0
.CODE
PUSH lString13_seti3_A2  ; Apilamos el label del String '"A2 :: seti3() "'. 
SWAP  ; CallNode. Acomodamos el THIS cada vez que generamos el codigo para un parametro. 
.CODE
PUSH L_MET_System_1_printSln
CALL  ; CallNode. Llamada al metodo 'printSln' de System. 
.CODE
LOAD 4  ; IdMethodCallNode. Cargamos el parametro 'i4'. 
.CODE
LOAD 3  ; AssignNode. Apilamos THIS 
SWAP  ; AssignNode. Invertimos el orden del tope de la pila. STOREREF usa los parametros en orden inverso (CIR, valor). 
STOREREF 2  ; AssignNode. El lado izquierdo es una variable de instancia de la clase 'A2'. 
STOREFP ; Se actualiza el FP para que apunte al RA del llamador
RET 2  ; Retornamos de la unidad 
.CODE
; INICIALIZAMOS EL CI DEL METODO 'print' DE LA CLASE 'A2'
L_MET_A2_3_print_5: LOADFP  ; Guardamos el ED al RA llamador 
LOADSP  ; Apilamos la locación donde empieza el RA de la unidad 
STOREFP  ; Actualizamos el FP con el valor del tope de la pila 
RMEM 2  ; Reservamos memoria para las variables locales del metodo 'print' 
.CODE
RMEM 1  ; IdMethodCallNode. Reservamos una locacion de memoria para el this ficticio. 
.CODE
.DATA
lString14_print_A2: DW "A2 :: print() :: i1 ", 0
.CODE
PUSH lString14_print_A2  ; Apilamos el label del String '"A2 :: print() :: i1 "'. 
SWAP  ; CallNode. Acomodamos el THIS cada vez que generamos el codigo para un parametro. 
.CODE
PUSH L_MET_System_1_printS
CALL  ; CallNode. Llamada al metodo 'printS' de System. 
.CODE
LOAD 3  ; MethodCallNode. Apilamos el THIS para invocar al metodo 'geti1'. 
RMEM 1  ; MethodCallNode. Reservamos una locacion de memoria para el resultado del metodo 'geti1' de la clase 'A2'. 
SWAP  ; MethodCallNode. Acomodamos el THIS haciendo un SWAP con RETVAL. 
DUP  ; MethodCallNode. Duplicamos la referencia al CIR para utilizarla en el LOADREF al asociar la VT para invocar al metodo 'geti1'. 
LOADREF 0  ; MethodCallNode. El offset de la VT en el CIR es siempre 0. Accedemos a la VT. 
LOADREF 1  ; MethodCallNode. Recuperamos la direccion del metodo 'geti1'. 
CALL  ; MethodCallNode. Llamamos al metodo 'geti1'. 
.CODE
STORE -1  ; AssignNode. El lado izquierdo es una variable local del metodo 'print'. 
.CODE
RMEM 1  ; IdMethodCallNode. Reservamos una locacion de memoria para el this ficticio. 
.CODE
.CODE
LOAD -1  ; IdMethodCallNode. Cargamos la variable local 'i2'. 
SWAP  ; CallNode. Acomodamos el THIS cada vez que generamos el codigo para un parametro. 
.CODE
PUSH L_MET_System_1_printIln
CALL  ; CallNode. Llamada al metodo 'printIln' de System. 
.CODE
RMEM 1  ; IdMethodCallNode. Reservamos una locacion de memoria para el this ficticio. 
.CODE
.DATA
lString15_print_A2: DW "A2 :: print() :: i3 ", 0
.CODE
PUSH lString15_print_A2  ; Apilamos el label del String '"A2 :: print() :: i3 "'. 
SWAP  ; CallNode. Acomodamos el THIS cada vez que generamos el codigo para un parametro. 
.CODE
PUSH L_MET_System_1_printS
CALL  ; CallNode. Llamada al metodo 'printS' de System. 
.CODE
LOAD 3  ; MethodCallNode. Apilamos el THIS para invocar al metodo 'geti3'. 
RMEM 1  ; MethodCallNode. Reservamos una locacion de memoria para el resultado del metodo 'geti3' de la clase 'A2'. 
SWAP  ; MethodCallNode. Acomodamos el THIS haciendo un SWAP con RETVAL. 
DUP  ; MethodCallNode. Duplicamos la referencia al CIR para utilizarla en el LOADREF al asociar la VT para invocar al metodo 'geti3'. 
LOADREF 0  ; MethodCallNode. El offset de la VT en el CIR es siempre 0. Accedemos a la VT. 
LOADREF 3  ; MethodCallNode. Recuperamos la direccion del metodo 'geti3'. 
CALL  ; MethodCallNode. Llamamos al metodo 'geti3'. 
.CODE
STORE 0  ; AssignNode. El lado izquierdo es una variable local del metodo 'print'. 
.CODE
RMEM 1  ; IdMethodCallNode. Reservamos una locacion de memoria para el this ficticio. 
.CODE
.CODE
LOAD 0  ; IdMethodCallNode. Cargamos la variable local 'i4'. 
SWAP  ; CallNode. Acomodamos el THIS cada vez que generamos el codigo para un parametro. 
.CODE
PUSH L_MET_System_1_printIln
CALL  ; CallNode. Llamada al metodo 'printIln' de System. 
FMEM 2  ; Liberamos la memoria de las variables locales del metodo 'print' 
STOREFP ; Se actualiza el FP para que apunte al RA del llamador
RET 1  ; Retornamos de la unidad 
.DATA
VT_A3_4: DW L_MET_A_2_printA_0, L_MET_A3_4_geti1_1, L_MET_A3_4_seti1_2, L_MET_A3_4_geti3_3, L_MET_A3_4_seti3_4, L_MET_A3_4_print_5, L_MET_A3_4_geti5_6, L_MET_A3_4_seti5_7, L_MET_A3_4_ret_8, L_MET_A3_4_main_9
.CODE
; INICIALIZAMOS EL CI DEL CONSTRUCTOR 'A3' DE LA CLASE 'A3'
L_CTOR_A3_4_A3: LOADFP  ; Guardamos el ED al RA llamador 
LOADSP  ; Apilamos la locación donde empieza el RA de la unidad 
STOREFP  ; Actualizamos el FP con el valor del tope de la pila 
.CODE
LOAD 6  ; IdMethodCallNode. Cargamos el parametro 'i2'. 
.CODE
LOAD 3  ; AssignNode. Apilamos THIS 
SWAP  ; AssignNode. Invertimos el orden del tope de la pila. STOREREF usa los parametros en orden inverso (CIR, valor). 
STOREREF 6  ; AssignNode. El lado izquierdo es una variable de instancia de la clase 'A3'. 
.CODE
LOAD 5  ; IdMethodCallNode. Cargamos el parametro 'i4'. 
.CODE
LOAD 3  ; AssignNode. Apilamos THIS 
SWAP  ; AssignNode. Invertimos el orden del tope de la pila. STOREREF usa los parametros en orden inverso (CIR, valor). 
STOREREF 5  ; AssignNode. El lado izquierdo es una variable de instancia de la clase 'A3'. 
.CODE
LOAD 4  ; IdMethodCallNode. Cargamos el parametro 'i6'. 
.CODE
LOAD 3  ; AssignNode. Apilamos THIS 
SWAP  ; AssignNode. Invertimos el orden del tope de la pila. STOREREF usa los parametros en orden inverso (CIR, valor). 
STOREREF 4  ; AssignNode. El lado izquierdo es una variable de instancia de la clase 'A3'. 
.CODE
RMEM 1  ; IdMethodCallNode. Reservamos una locacion de memoria para el this ficticio. 
.CODE
.DATA
lString16_A3_A3: DW "A3 :: A3() :: i1 ", 0
.CODE
PUSH lString16_A3_A3  ; Apilamos el label del String '"A3 :: A3() :: i1 "'. 
SWAP  ; CallNode. Acomodamos el THIS cada vez que generamos el codigo para un parametro. 
.CODE
PUSH L_MET_System_1_printSln
CALL  ; CallNode. Llamada al metodo 'printSln' de System. 
.CODE
RMEM 1  ; IdMethodCallNode. Reservamos una locacion de memoria para el this ficticio. 
.CODE
.CODE
LOAD 3  ; IdMethodCallNode. Apilamos el THIS para poder acceder al CIR. 
LOADREF 6  ; IdMethodCallNode. Cargamos la variable de instancia 'i1'. 
SWAP  ; CallNode. Acomodamos el THIS cada vez que generamos el codigo para un parametro. 
.CODE
PUSH L_MET_System_1_printI
CALL  ; CallNode. Llamada al metodo 'printI' de System. 
.CODE
RMEM 1  ; IdMethodCallNode. Reservamos una locacion de memoria para el this ficticio. 
.CODE
PUSH 10  ; LiteralNode. Apilo el caracter nl. 
SWAP  ; CallNode. Acomodamos el THIS cada vez que generamos el codigo para un parametro. 
.CODE
PUSH L_MET_System_1_printC
CALL  ; CallNode. Llamada al metodo 'printC' de System. 
.CODE
RMEM 1  ; IdMethodCallNode. Reservamos una locacion de memoria para el this ficticio. 
.CODE
.DATA
lString17_A3_A3: DW "A3 :: A3() :: i3 ", 0
.CODE
PUSH lString17_A3_A3  ; Apilamos el label del String '"A3 :: A3() :: i3 "'. 
SWAP  ; CallNode. Acomodamos el THIS cada vez que generamos el codigo para un parametro. 
.CODE
PUSH L_MET_System_1_printSln
CALL  ; CallNode. Llamada al metodo 'printSln' de System. 
.CODE
RMEM 1  ; IdMethodCallNode. Reservamos una locacion de memoria para el this ficticio. 
.CODE
.CODE
LOAD 3  ; IdMethodCallNode. Apilamos el THIS para poder acceder al CIR. 
LOADREF 5  ; IdMethodCallNode. Cargamos la variable de instancia 'i3'. 
SWAP  ; CallNode. Acomodamos el THIS cada vez que generamos el codigo para un parametro. 
.CODE
PUSH L_MET_System_1_printI
CALL  ; CallNode. Llamada al metodo 'printI' de System. 
.CODE
RMEM 1  ; IdMethodCallNode. Reservamos una locacion de memoria para el this ficticio. 
.CODE
PUSH 10  ; LiteralNode. Apilo el caracter nl. 
SWAP  ; CallNode. Acomodamos el THIS cada vez que generamos el codigo para un parametro. 
.CODE
PUSH L_MET_System_1_printC
CALL  ; CallNode. Llamada al metodo 'printC' de System. 
.CODE
RMEM 1  ; IdMethodCallNode. Reservamos una locacion de memoria para el this ficticio. 
.CODE
.DATA
lString18_A3_A3: DW "A3 :: A3() :: i5 ", 0
.CODE
PUSH lString18_A3_A3  ; Apilamos el label del String '"A3 :: A3() :: i5 "'. 
SWAP  ; CallNode. Acomodamos el THIS cada vez que generamos el codigo para un parametro. 
.CODE
PUSH L_MET_System_1_printSln
CALL  ; CallNode. Llamada al metodo 'printSln' de System. 
.CODE
RMEM 1  ; IdMethodCallNode. Reservamos una locacion de memoria para el this ficticio. 
.CODE
.CODE
LOAD 3  ; IdMethodCallNode. Apilamos el THIS para poder acceder al CIR. 
LOADREF 4  ; IdMethodCallNode. Cargamos la variable de instancia 'i5'. 
SWAP  ; CallNode. Acomodamos el THIS cada vez que generamos el codigo para un parametro. 
.CODE
PUSH L_MET_System_1_printIln
CALL  ; CallNode. Llamada al metodo 'printIln' de System. 
.CODE
RMEM 1  ; IdMethodCallNode. Reservamos una locacion de memoria para el this ficticio. 
.CODE
PUSH 10  ; LiteralNode. Apilo el caracter nl. 
SWAP  ; CallNode. Acomodamos el THIS cada vez que generamos el codigo para un parametro. 
.CODE
PUSH L_MET_System_1_printC
CALL  ; CallNode. Llamada al metodo 'printC' de System. 
STOREFP ; Se actualiza el FP para que apunte al RA del llamador
RET 4  ; Retornamos de la unidad 
.CODE
; INICIALIZAMOS EL CI DEL METODO 'geti1' DE LA CLASE 'A3'
L_MET_A3_4_geti1_1: LOADFP  ; Guardamos el ED al RA llamador 
LOADSP  ; Apilamos la locación donde empieza el RA de la unidad 
STOREFP  ; Actualizamos el FP con el valor del tope de la pila 
RMEM 1  ; Reservamos memoria para las variables locales del metodo 'geti1' 
.CODE
RMEM 1  ; IdMethodCallNode. Reservamos una locacion de memoria para el this ficticio. 
.CODE
.DATA
lString19_geti1_A3: DW "A3 :: geti1() :: i1", 0
.CODE
PUSH lString19_geti1_A3  ; Apilamos el label del String '"A3 :: geti1() :: i1"'. 
SWAP  ; CallNode. Acomodamos el THIS cada vez que generamos el codigo para un parametro. 
.CODE
PUSH L_MET_System_1_printSln
CALL  ; CallNode. Llamada al metodo 'printSln' de System. 
.CODE
LOAD 3  ; IdMethodCallNode. Apilamos el THIS para poder acceder al CIR. 
LOADREF 6  ; IdMethodCallNode. Cargamos la variable de instancia 'i1'. 
.CODE
STORE 0  ; AssignNode. El lado izquierdo es una variable local del metodo 'geti1'. 
.CODE
LOAD 0  ; IdMethodCallNode. Cargamos la variable local 'ret'. 
.CODE
; Retorno de expresion del metodo 'geti1' de la clase 'A3'.
STORE 4  ; ReturnExpNode. Almacenamos el retorno del metodo 'geti1' de la clase 'A3'. 
FMEM 1  ; ReturnExpNode. Liberamos el espacio usado por las variables locales del metodo 'geti1' de la clase 'A3'. 
STOREFP  ; ReturnExpNode. Actualizamos el FP para que apunte al RA del llamador 
RET 1  ; ReturnExpNode. Retornamos de la unidad liberando el espacio que ocupaban los parametros y el THIS del metodo 'geti1' de la clase 'A3'. 
FMEM 1  ; Liberamos la memoria de las variables locales del metodo 'geti1' 
STOREFP ; Se actualiza el FP para que apunte al RA del llamador
RET 1  ; Retornamos de la unidad 
.CODE
; INICIALIZAMOS EL CI DEL METODO 'geti3' DE LA CLASE 'A3'
L_MET_A3_4_geti3_3: LOADFP  ; Guardamos el ED al RA llamador 
LOADSP  ; Apilamos la locación donde empieza el RA de la unidad 
STOREFP  ; Actualizamos el FP con el valor del tope de la pila 
RMEM 1  ; Reservamos memoria para las variables locales del metodo 'geti3' 
.CODE
RMEM 1  ; IdMethodCallNode. Reservamos una locacion de memoria para el this ficticio. 
.CODE
.DATA
lString20_geti3_A3: DW "A3 :: geti3() :: i3 ", 0
.CODE
PUSH lString20_geti3_A3  ; Apilamos el label del String '"A3 :: geti3() :: i3 "'. 
SWAP  ; CallNode. Acomodamos el THIS cada vez que generamos el codigo para un parametro. 
.CODE
PUSH L_MET_System_1_printSln
CALL  ; CallNode. Llamada al metodo 'printSln' de System. 
.CODE
LOAD 3  ; IdMethodCallNode. Apilamos el THIS para poder acceder al CIR. 
LOADREF 5  ; IdMethodCallNode. Cargamos la variable de instancia 'i3'. 
.CODE
STORE 0  ; AssignNode. El lado izquierdo es una variable local del metodo 'geti3'. 
.CODE
LOAD 0  ; IdMethodCallNode. Cargamos la variable local 'ret'. 
.CODE
; Retorno de expresion del metodo 'geti3' de la clase 'A3'.
STORE 4  ; ReturnExpNode. Almacenamos el retorno del metodo 'geti3' de la clase 'A3'. 
FMEM 1  ; ReturnExpNode. Liberamos el espacio usado por las variables locales del metodo 'geti3' de la clase 'A3'. 
STOREFP  ; ReturnExpNode. Actualizamos el FP para que apunte al RA del llamador 
RET 1  ; ReturnExpNode. Retornamos de la unidad liberando el espacio que ocupaban los parametros y el THIS del metodo 'geti3' de la clase 'A3'. 
FMEM 1  ; Liberamos la memoria de las variables locales del metodo 'geti3' 
STOREFP ; Se actualiza el FP para que apunte al RA del llamador
RET 1  ; Retornamos de la unidad 
.CODE
; INICIALIZAMOS EL CI DEL METODO 'geti5' DE LA CLASE 'A3'
L_MET_A3_4_geti5_6: LOADFP  ; Guardamos el ED al RA llamador 
LOADSP  ; Apilamos la locación donde empieza el RA de la unidad 
STOREFP  ; Actualizamos el FP con el valor del tope de la pila 
RMEM 1  ; Reservamos memoria para las variables locales del metodo 'geti5' 
.CODE
RMEM 1  ; IdMethodCallNode. Reservamos una locacion de memoria para el this ficticio. 
.CODE
.DATA
lString21_geti5_A3: DW "A3 :: geti5() :: i5 ", 0
.CODE
PUSH lString21_geti5_A3  ; Apilamos el label del String '"A3 :: geti5() :: i5 "'. 
SWAP  ; CallNode. Acomodamos el THIS cada vez que generamos el codigo para un parametro. 
.CODE
PUSH L_MET_System_1_printSln
CALL  ; CallNode. Llamada al metodo 'printSln' de System. 
.CODE
LOAD 3  ; IdMethodCallNode. Apilamos el THIS para poder acceder al CIR. 
LOADREF 4  ; IdMethodCallNode. Cargamos la variable de instancia 'i5'. 
.CODE
STORE 0  ; AssignNode. El lado izquierdo es una variable local del metodo 'geti5'. 
.CODE
LOAD 0  ; IdMethodCallNode. Cargamos la variable local 'ret'. 
.CODE
; Retorno de expresion del metodo 'geti5' de la clase 'A3'.
STORE 4  ; ReturnExpNode. Almacenamos el retorno del metodo 'geti5' de la clase 'A3'. 
FMEM 1  ; ReturnExpNode. Liberamos el espacio usado por las variables locales del metodo 'geti5' de la clase 'A3'. 
STOREFP  ; ReturnExpNode. Actualizamos el FP para que apunte al RA del llamador 
RET 1  ; ReturnExpNode. Retornamos de la unidad liberando el espacio que ocupaban los parametros y el THIS del metodo 'geti5' de la clase 'A3'. 
FMEM 1  ; Liberamos la memoria de las variables locales del metodo 'geti5' 
STOREFP ; Se actualiza el FP para que apunte al RA del llamador
RET 1  ; Retornamos de la unidad 
.CODE
; INICIALIZAMOS EL CI DEL METODO 'seti1' DE LA CLASE 'A3'
L_MET_A3_4_seti1_2: LOADFP  ; Guardamos el ED al RA llamador 
LOADSP  ; Apilamos la locación donde empieza el RA de la unidad 
STOREFP  ; Actualizamos el FP con el valor del tope de la pila 
.CODE
RMEM 1  ; IdMethodCallNode. Reservamos una locacion de memoria para el this ficticio. 
.CODE
.DATA
lString22_seti1_A3: DW "A3 :: seti1() ", 0
.CODE
PUSH lString22_seti1_A3  ; Apilamos el label del String '"A3 :: seti1() "'. 
SWAP  ; CallNode. Acomodamos el THIS cada vez que generamos el codigo para un parametro. 
.CODE
PUSH L_MET_System_1_printSln
CALL  ; CallNode. Llamada al metodo 'printSln' de System. 
.CODE
LOAD 4  ; IdMethodCallNode. Cargamos el parametro 'i2'. 
.CODE
LOAD 3  ; AssignNode. Apilamos THIS 
SWAP  ; AssignNode. Invertimos el orden del tope de la pila. STOREREF usa los parametros en orden inverso (CIR, valor). 
STOREREF 6  ; AssignNode. El lado izquierdo es una variable de instancia de la clase 'A3'. 
STOREFP ; Se actualiza el FP para que apunte al RA del llamador
RET 2  ; Retornamos de la unidad 
.CODE
; INICIALIZAMOS EL CI DEL METODO 'seti3' DE LA CLASE 'A3'
L_MET_A3_4_seti3_4: LOADFP  ; Guardamos el ED al RA llamador 
LOADSP  ; Apilamos la locación donde empieza el RA de la unidad 
STOREFP  ; Actualizamos el FP con el valor del tope de la pila 
.CODE
RMEM 1  ; IdMethodCallNode. Reservamos una locacion de memoria para el this ficticio. 
.CODE
.DATA
lString23_seti3_A3: DW "A3 :: seti3() ", 0
.CODE
PUSH lString23_seti3_A3  ; Apilamos el label del String '"A3 :: seti3() "'. 
SWAP  ; CallNode. Acomodamos el THIS cada vez que generamos el codigo para un parametro. 
.CODE
PUSH L_MET_System_1_printSln
CALL  ; CallNode. Llamada al metodo 'printSln' de System. 
.CODE
LOAD 4  ; IdMethodCallNode. Cargamos el parametro 'i4'. 
.CODE
LOAD 3  ; AssignNode. Apilamos THIS 
SWAP  ; AssignNode. Invertimos el orden del tope de la pila. STOREREF usa los parametros en orden inverso (CIR, valor). 
STOREREF 5  ; AssignNode. El lado izquierdo es una variable de instancia de la clase 'A3'. 
STOREFP ; Se actualiza el FP para que apunte al RA del llamador
RET 2  ; Retornamos de la unidad 
.CODE
; INICIALIZAMOS EL CI DEL METODO 'seti5' DE LA CLASE 'A3'
L_MET_A3_4_seti5_7: LOADFP  ; Guardamos el ED al RA llamador 
LOADSP  ; Apilamos la locación donde empieza el RA de la unidad 
STOREFP  ; Actualizamos el FP con el valor del tope de la pila 
.CODE
RMEM 1  ; IdMethodCallNode. Reservamos una locacion de memoria para el this ficticio. 
.CODE
.DATA
lString24_seti5_A3: DW "A3 :: seti5() ", 0
.CODE
PUSH lString24_seti5_A3  ; Apilamos el label del String '"A3 :: seti5() "'. 
SWAP  ; CallNode. Acomodamos el THIS cada vez que generamos el codigo para un parametro. 
.CODE
PUSH L_MET_System_1_printSln
CALL  ; CallNode. Llamada al metodo 'printSln' de System. 
.CODE
LOAD 4  ; IdMethodCallNode. Cargamos el parametro 'i6'. 
.CODE
LOAD 3  ; AssignNode. Apilamos THIS 
SWAP  ; AssignNode. Invertimos el orden del tope de la pila. STOREREF usa los parametros en orden inverso (CIR, valor). 
STOREREF 4  ; AssignNode. El lado izquierdo es una variable de instancia de la clase 'A3'. 
STOREFP ; Se actualiza el FP para que apunte al RA del llamador
RET 2  ; Retornamos de la unidad 
.CODE
; INICIALIZAMOS EL CI DEL METODO 'print' DE LA CLASE 'A3'
L_MET_A3_4_print_5: LOADFP  ; Guardamos el ED al RA llamador 
LOADSP  ; Apilamos la locación donde empieza el RA de la unidad 
STOREFP  ; Actualizamos el FP con el valor del tope de la pila 
RMEM 3  ; Reservamos memoria para las variables locales del metodo 'print' 
.CODE
RMEM 1  ; IdMethodCallNode. Reservamos una locacion de memoria para el this ficticio. 
.CODE
.DATA
lString25_print_A3: DW "A3 :: print() :: i1 ", 0
.CODE
PUSH lString25_print_A3  ; Apilamos el label del String '"A3 :: print() :: i1 "'. 
SWAP  ; CallNode. Acomodamos el THIS cada vez que generamos el codigo para un parametro. 
.CODE
PUSH L_MET_System_1_printSln
CALL  ; CallNode. Llamada al metodo 'printSln' de System. 
.CODE
LOAD 3  ; MethodCallNode. Apilamos el THIS para invocar al metodo 'geti1'. 
RMEM 1  ; MethodCallNode. Reservamos una locacion de memoria para el resultado del metodo 'geti1' de la clase 'A3'. 
SWAP  ; MethodCallNode. Acomodamos el THIS haciendo un SWAP con RETVAL. 
DUP  ; MethodCallNode. Duplicamos la referencia al CIR para utilizarla en el LOADREF al asociar la VT para invocar al metodo 'geti1'. 
LOADREF 0  ; MethodCallNode. El offset de la VT en el CIR es siempre 0. Accedemos a la VT. 
LOADREF 1  ; MethodCallNode. Recuperamos la direccion del metodo 'geti1'. 
CALL  ; MethodCallNode. Llamamos al metodo 'geti1'. 
.CODE
STORE -2  ; AssignNode. El lado izquierdo es una variable local del metodo 'print'. 
.CODE
RMEM 1  ; IdMethodCallNode. Reservamos una locacion de memoria para el this ficticio. 
.CODE
.CODE
LOAD -2  ; IdMethodCallNode. Cargamos la variable local 'i2'. 
SWAP  ; CallNode. Acomodamos el THIS cada vez que generamos el codigo para un parametro. 
.CODE
PUSH L_MET_System_1_printIln
CALL  ; CallNode. Llamada al metodo 'printIln' de System. 
.CODE
RMEM 1  ; IdMethodCallNode. Reservamos una locacion de memoria para el this ficticio. 
.CODE
PUSH 10  ; LiteralNode. Apilo el caracter nl. 
SWAP  ; CallNode. Acomodamos el THIS cada vez que generamos el codigo para un parametro. 
.CODE
PUSH L_MET_System_1_printC
CALL  ; CallNode. Llamada al metodo 'printC' de System. 
.CODE
RMEM 1  ; IdMethodCallNode. Reservamos una locacion de memoria para el this ficticio. 
.CODE
.DATA
lString26_print_A3: DW "A3 :: print() :: i3 ", 0
.CODE
PUSH lString26_print_A3  ; Apilamos el label del String '"A3 :: print() :: i3 "'. 
SWAP  ; CallNode. Acomodamos el THIS cada vez que generamos el codigo para un parametro. 
.CODE
PUSH L_MET_System_1_printSln
CALL  ; CallNode. Llamada al metodo 'printSln' de System. 
.CODE
LOAD 3  ; MethodCallNode. Apilamos el THIS para invocar al metodo 'geti3'. 
RMEM 1  ; MethodCallNode. Reservamos una locacion de memoria para el resultado del metodo 'geti3' de la clase 'A3'. 
SWAP  ; MethodCallNode. Acomodamos el THIS haciendo un SWAP con RETVAL. 
DUP  ; MethodCallNode. Duplicamos la referencia al CIR para utilizarla en el LOADREF al asociar la VT para invocar al metodo 'geti3'. 
LOADREF 0  ; MethodCallNode. El offset de la VT en el CIR es siempre 0. Accedemos a la VT. 
LOADREF 3  ; MethodCallNode. Recuperamos la direccion del metodo 'geti3'. 
CALL  ; MethodCallNode. Llamamos al metodo 'geti3'. 
.CODE
STORE -1  ; AssignNode. El lado izquierdo es una variable local del metodo 'print'. 
.CODE
RMEM 1  ; IdMethodCallNode. Reservamos una locacion de memoria para el this ficticio. 
.CODE
.CODE
LOAD -1  ; IdMethodCallNode. Cargamos la variable local 'i4'. 
SWAP  ; CallNode. Acomodamos el THIS cada vez que generamos el codigo para un parametro. 
.CODE
PUSH L_MET_System_1_printIln
CALL  ; CallNode. Llamada al metodo 'printIln' de System. 
.CODE
RMEM 1  ; IdMethodCallNode. Reservamos una locacion de memoria para el this ficticio. 
.CODE
PUSH 10  ; LiteralNode. Apilo el caracter nl. 
SWAP  ; CallNode. Acomodamos el THIS cada vez que generamos el codigo para un parametro. 
.CODE
PUSH L_MET_System_1_printC
CALL  ; CallNode. Llamada al metodo 'printC' de System. 
.CODE
RMEM 1  ; IdMethodCallNode. Reservamos una locacion de memoria para el this ficticio. 
.CODE
.DATA
lString27_print_A3: DW "A3 :: print() :: i5 ", 0
.CODE
PUSH lString27_print_A3  ; Apilamos el label del String '"A3 :: print() :: i5 "'. 
SWAP  ; CallNode. Acomodamos el THIS cada vez que generamos el codigo para un parametro. 
.CODE
PUSH L_MET_System_1_printSln
CALL  ; CallNode. Llamada al metodo 'printSln' de System. 
.CODE
LOAD 3  ; MethodCallNode. Apilamos el THIS para invocar al metodo 'geti5'. 
RMEM 1  ; MethodCallNode. Reservamos una locacion de memoria para el resultado del metodo 'geti5' de la clase 'A3'. 
SWAP  ; MethodCallNode. Acomodamos el THIS haciendo un SWAP con RETVAL. 
DUP  ; MethodCallNode. Duplicamos la referencia al CIR para utilizarla en el LOADREF al asociar la VT para invocar al metodo 'geti5'. 
LOADREF 0  ; MethodCallNode. El offset de la VT en el CIR es siempre 0. Accedemos a la VT. 
LOADREF 6  ; MethodCallNode. Recuperamos la direccion del metodo 'geti5'. 
CALL  ; MethodCallNode. Llamamos al metodo 'geti5'. 
.CODE
STORE 0  ; AssignNode. El lado izquierdo es una variable local del metodo 'print'. 
.CODE
RMEM 1  ; IdMethodCallNode. Reservamos una locacion de memoria para el this ficticio. 
.CODE
.CODE
LOAD 0  ; IdMethodCallNode. Cargamos la variable local 'i6'. 
SWAP  ; CallNode. Acomodamos el THIS cada vez que generamos el codigo para un parametro. 
.CODE
PUSH L_MET_System_1_printIln
CALL  ; CallNode. Llamada al metodo 'printIln' de System. 
.CODE
RMEM 1  ; IdMethodCallNode. Reservamos una locacion de memoria para el this ficticio. 
.CODE
PUSH 10  ; LiteralNode. Apilo el caracter nl. 
SWAP  ; CallNode. Acomodamos el THIS cada vez que generamos el codigo para un parametro. 
.CODE
PUSH L_MET_System_1_printC
CALL  ; CallNode. Llamada al metodo 'printC' de System. 
FMEM 3  ; Liberamos la memoria de las variables locales del metodo 'print' 
STOREFP ; Se actualiza el FP para que apunte al RA del llamador
RET 1  ; Retornamos de la unidad 
.CODE
; INICIALIZAMOS EL CI DEL METODO 'ret' DE LA CLASE 'A3'
L_MET_A3_4_ret_8: LOADFP  ; Guardamos el ED al RA llamador 
LOADSP  ; Apilamos la locación donde empieza el RA de la unidad 
STOREFP  ; Actualizamos el FP con el valor del tope de la pila 
.CODE
RMEM 1  ; NewNode. Llamada al constructor de la clase 'A3'. Se reserva memoria para la referencia al nuevo CIR. 
PUSH 7  ; NewNode. Apilamos la cantidad de variables de instancia del nuevo CIR mas el espacio para la VT. 
PUSH L_SIMPLE_MALLOC  ; NewNode. Apilamos la direccion de la rutina para reservar memoria en el heap. 
CALL  ; NewNode. Invocamos a la rutina en el tope de la pila (lsimple_malloc). 
DUP  ; NewNode. Duplicamos la referencia al nuevo CIR para el STOREREF. 
PUSH VT_A3_4  ; NewNode. Apilamos la direccion del comienzo de la VT del id en la creacion de un CIR. 
STOREREF 0  ; NewNode. Guardamos las referencia a la VT en el CIR creado. El offset 0 en el CIR se corresponde a la VT. 
DUP  ; NewNode. Duplicamos el THIS para el RA del constructor quedando, al finalizar la ejecucion, en el tope de la pila. 
.CODE
PUSH 1
.CODE
SWAP  ; NewNode. Acomodamos el THIS cada vez que generamos el codigo para un parametro. 
.CODE
PUSH 2
.CODE
SWAP  ; NewNode. Acomodamos el THIS cada vez que generamos el codigo para un parametro. 
.CODE
PUSH 3
.CODE
SWAP  ; NewNode. Acomodamos el THIS cada vez que generamos el codigo para un parametro. 
.CODE
PUSH L_CTOR_A3_4_A3  ; NewNode. Apilamos la direccion del constructor de la clase 'A3'. 
CALL  ; NewNode. Invocamos la rutina del constructor de la clase 'A3'. 
.CODE
; Retorno de expresion del metodo 'ret' de la clase 'A3'.
STORE 4  ; ReturnExpNode. Almacenamos el retorno del metodo 'ret' de la clase 'A3'. 
STOREFP  ; ReturnExpNode. Actualizamos el FP para que apunte al RA del llamador 
RET 1  ; ReturnExpNode. Retornamos de la unidad liberando el espacio que ocupaban los parametros y el THIS del metodo 'ret' de la clase 'A3'. 
STOREFP ; Se actualiza el FP para que apunte al RA del llamador
RET 1  ; Retornamos de la unidad 
.CODE
; INICIALIZAMOS EL CI DEL METODO 'main' DE LA CLASE 'A3'
L_MET_A3_4_main_9: LOADFP  ; Guardamos el ED al RA llamador 
LOADSP  ; Apilamos la locación donde empieza el RA de la unidad 
STOREFP  ; Actualizamos el FP con el valor del tope de la pila 
RMEM 1  ; Reservamos memoria para las variables locales del metodo 'main' 
.CODE
RMEM 1  ; NewNode. Llamada al constructor de la clase 'A3'. Se reserva memoria para la referencia al nuevo CIR. 
PUSH 7  ; NewNode. Apilamos la cantidad de variables de instancia del nuevo CIR mas el espacio para la VT. 
PUSH L_SIMPLE_MALLOC  ; NewNode. Apilamos la direccion de la rutina para reservar memoria en el heap. 
CALL  ; NewNode. Invocamos a la rutina en el tope de la pila (lsimple_malloc). 
DUP  ; NewNode. Duplicamos la referencia al nuevo CIR para el STOREREF. 
PUSH VT_A3_4  ; NewNode. Apilamos la direccion del comienzo de la VT del id en la creacion de un CIR. 
STOREREF 0  ; NewNode. Guardamos las referencia a la VT en el CIR creado. El offset 0 en el CIR se corresponde a la VT. 
DUP  ; NewNode. Duplicamos el THIS para el RA del constructor quedando, al finalizar la ejecucion, en el tope de la pila. 
.CODE
PUSH 3
.CODE
SWAP  ; NewNode. Acomodamos el THIS cada vez que generamos el codigo para un parametro. 
.CODE
PUSH 4
.CODE
SWAP  ; NewNode. Acomodamos el THIS cada vez que generamos el codigo para un parametro. 
.CODE
PUSH 5
.CODE
SWAP  ; NewNode. Acomodamos el THIS cada vez que generamos el codigo para un parametro. 
.CODE
PUSH L_CTOR_A3_4_A3  ; NewNode. Apilamos la direccion del constructor de la clase 'A3'. 
CALL  ; NewNode. Invocamos la rutina del constructor de la clase 'A3'. 
.CODE
STORE 0  ; AssignNode. El lado izquierdo es una variable local del metodo 'main'. 
.CODE
LOAD 0  ; IdMethodCallNode. Cargamos la variable local 'a3'. 
.CODE
.CODE
DUP  ; CallNode. Duplicamos la referencia al CIR para utilizarla en el LOADREF al asociar la VT para invocar al metodo 'print'. 
LOADREF 0  ; CallNode. El offset de la VT en el CIR es siempre 0. Accedemos a la VT. 
LOADREF 5  ; CallNode. Recuperamos la direccion del metodo 'print'. 
CALL  ; CallNode. Llamamos al metodo 'print'. 
.CODE
LOAD 0  ; IdMethodCallNode. Cargamos la variable local 'a3'. 
.CODE
RMEM 1  ; CallNode. Reservamos una locacion de memoria para el resultado del metodo 'ret' de la clase 'A3'. 
SWAP  ; CallNode. Acomodamos el THIS haciendo un SWAP con RETVAL. 
.CODE
DUP  ; CallNode. Duplicamos la referencia al CIR para utilizarla en el LOADREF al asociar la VT para invocar al metodo 'ret'. 
LOADREF 0  ; CallNode. El offset de la VT en el CIR es siempre 0. Accedemos a la VT. 
LOADREF 8  ; CallNode. Recuperamos la direccion del metodo 'ret'. 
CALL  ; CallNode. Llamamos al metodo 'ret'. 
.CODE
.CODE
DUP  ; CallNode. Duplicamos la referencia al CIR para utilizarla en el LOADREF al asociar la VT para invocar al metodo 'printA'. 
LOADREF 0  ; CallNode. El offset de la VT en el CIR es siempre 0. Accedemos a la VT. 
LOADREF 0  ; CallNode. Recuperamos la direccion del metodo 'printA'. 
CALL  ; CallNode. Llamamos al metodo 'printA'. 
FMEM 1  ; Liberamos la memoria de las variables locales del metodo 'main' 
STOREFP ; Se actualiza el FP para que apunte al RA del llamador
RET 1  ; Retornamos de la unidad 
